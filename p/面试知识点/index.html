<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='开场白 您好,我叫XX.统招本科毕业于XX,有6年开发经验,2年管理经验,从0到1构建多个项目,可带3-5人小团队.具有独立完成复杂工作,指导初中级开发的能力.同时熟悉系统设计、性能优化、敏捷开发. 在上⼀个公司我参与了中国山东网项目开发,主要职责是对开源框架进行微服务改造,核心业务模块拆分以及负责开发一些与平台运营相关的系统.
集合 List | ArrayList | LinkedList | CopyOnWriteArrayList Set | HashSet | LinkedHashSet | TreeSet Queue | PriorityQueue | BlockingQueue | DelayQueue Map | HashMap | LinkedHashMap | ConcurrentHashMap 多线程 线程的生命周期和状态 死锁 | 避免死锁 Java 内存模型 volatile 乐观锁与悲观锁 synchronized ReentrantLock | Condition ReentrantReadWriteLock | StampedLock ThreadLocal 线程池 | ThreadPoolExcutor | 参数 常见并发容器 AQS | 常见同步工具类 Semaphore (permits accquire(permits&amp;ndash;) release(permits++) ) 使用场景：控制并发访问量和单机限流 CountDownLatch (count countdown(count&amp;ndash;) await(count==0)) 使用场景：并行任务和同步操作 CyclicBarrier (parties await) 使用场景：主要应用场景和 CountDownLatch 类似 Atomic | CAS算法 Unsafe.'><meta name=keywords content="面试"><title>面试知识点</title>
<link rel=canonical href=https://blog.icharles.work/p/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/><link rel=stylesheet href=/scss/style.min.e073fd66b0d302896ef41123ea7f4fa98e761045e738a0f8d32c25332064e1f3.css><meta property='og:title' content='面试知识点'><meta property='og:description' content='开场白 您好,我叫XX.统招本科毕业于XX,有6年开发经验,2年管理经验,从0到1构建多个项目,可带3-5人小团队.具有独立完成复杂工作,指导初中级开发的能力.同时熟悉系统设计、性能优化、敏捷开发. 在上⼀个公司我参与了中国山东网项目开发,主要职责是对开源框架进行微服务改造,核心业务模块拆分以及负责开发一些与平台运营相关的系统.
集合 List | ArrayList | LinkedList | CopyOnWriteArrayList Set | HashSet | LinkedHashSet | TreeSet Queue | PriorityQueue | BlockingQueue | DelayQueue Map | HashMap | LinkedHashMap | ConcurrentHashMap 多线程 线程的生命周期和状态 死锁 | 避免死锁 Java 内存模型 volatile 乐观锁与悲观锁 synchronized ReentrantLock | Condition ReentrantReadWriteLock | StampedLock ThreadLocal 线程池 | ThreadPoolExcutor | 参数 常见并发容器 AQS | 常见同步工具类 Semaphore (permits accquire(permits&amp;ndash;) release(permits++) ) 使用场景：控制并发访问量和单机限流 CountDownLatch (count countdown(count&amp;ndash;) await(count==0)) 使用场景：并行任务和同步操作 CyclicBarrier (parties await) 使用场景：主要应用场景和 CountDownLatch 类似 Atomic | CAS算法 Unsafe.'><meta property='og:url' content='https://blog.icharles.work/p/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/'><meta property='og:site_name' content='天才熊猫君'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='面试'><meta property='article:published_time' content='2024-04-10T13:36:34+08:00'><meta property='article:modified_time' content='2024-04-10T13:36:34+08:00'><meta name=twitter:title content="面试知识点"><meta name=twitter:description content="开场白 您好,我叫XX.统招本科毕业于XX,有6年开发经验,2年管理经验,从0到1构建多个项目,可带3-5人小团队.具有独立完成复杂工作,指导初中级开发的能力.同时熟悉系统设计、性能优化、敏捷开发. 在上⼀个公司我参与了中国山东网项目开发,主要职责是对开源框架进行微服务改造,核心业务模块拆分以及负责开发一些与平台运营相关的系统.
集合 List | ArrayList | LinkedList | CopyOnWriteArrayList Set | HashSet | LinkedHashSet | TreeSet Queue | PriorityQueue | BlockingQueue | DelayQueue Map | HashMap | LinkedHashMap | ConcurrentHashMap 多线程 线程的生命周期和状态 死锁 | 避免死锁 Java 内存模型 volatile 乐观锁与悲观锁 synchronized ReentrantLock | Condition ReentrantReadWriteLock | StampedLock ThreadLocal 线程池 | ThreadPoolExcutor | 参数 常见并发容器 AQS | 常见同步工具类 Semaphore (permits accquire(permits&amp;ndash;) release(permits++) ) 使用场景：控制并发访问量和单机限流 CountDownLatch (count countdown(count&amp;ndash;) await(count==0)) 使用场景：并行任务和同步操作 CyclicBarrier (parties await) 使用场景：主要应用场景和 CountDownLatch 类似 Atomic | CAS算法 Unsafe."><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu767de0015c2f1504955e044ed064de0d_45470_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>天才熊猫君</a></h1><h2 class=site-description>想到就去做</h2></div></header><ol class=social-menu><li><a href=https://github.com/pendj target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 640 640"><path d="M319.988 7.973C143.293 7.973.0 151.242.0 327.96c0 141.392 91.678 261.298 218.826 303.63 16.004 2.964 21.886-6.957 21.886-15.414.0-7.63-.319-32.835-.449-59.552-89.032 19.359-107.8-37.772-107.8-37.772-14.552-36.993-35.529-46.831-35.529-46.831-29.032-19.879 2.209-19.442 2.209-19.442 32.126 2.245 49.04 32.954 49.04 32.954 28.56 48.922 74.883 34.76 93.131 26.598 2.882-20.681 11.15-34.807 20.315-42.803-71.08-8.067-145.797-35.516-145.797-158.14.0-34.926 12.52-63.485 32.965-85.88-3.33-8.078-14.291-40.606 3.083-84.674.0.0 26.87-8.61 88.029 32.8 25.512-7.075 52.878-10.642 80.056-10.76 27.2.118 54.614 3.673 80.162 10.76 61.076-41.386 87.922-32.8 87.922-32.8 17.398 44.08 6.485 76.631 3.154 84.675 20.516 22.394 32.93 50.953 32.93 85.879.0 122.907-74.883 149.93-146.117 157.856 11.481 9.921 21.733 29.398 21.733 59.233.0 42.792-.366 77.28-.366 87.804.0 8.516 5.764 18.473 21.992 15.354 127.076-42.354 218.637-162.274 218.637-303.582.0-176.695-143.269-319.988-320-319.988l-.023.107z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/%E9%93%BE%E6%8E%A5/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://blog.icharles.work/ selected></option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#开场白>开场白</a></li><li><a href=#集合>集合</a></li><li><a href=#多线程>多线程</a></li><li><a href=#jvm>JVM</a></li><li><a href=#spring-spring-mvc-springboot>Spring Spring MVC SpringBoot</a></li><li><a href=#mysql>MySQL</a></li><li><a href=#redis>Redis</a></li><li><a href=#分布式>分布式</a></li><li><a href=#nacos--elasticsearch--kafka>Nacos | ElasticSearch | Kafka</a><ol><li><a href=#nacos>Nacos</a></li><li><a href=#elasticsearch>ElasticSearch</a></li><li><a href=#kafka>Kafka</a></li></ol></li><li><a href=#你还有什么要问我的吗>你还有什么要问我的吗</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E9%9D%A2%E8%AF%95/>面试</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/>面试知识点</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-04-10</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><h2 id=开场白>开场白</h2><p>您好,我叫XX.统招本科毕业于XX,有6年开发经验,2年管理经验,从0到1构建多个项目,可带3-5人小团队.具有独立完成复杂工作,指导初中级开发的能力.同时熟悉系统设计、性能优化、敏捷开发.
在上⼀个公司我参与了中国山东网项目开发,主要职责是对开源框架进行微服务改造,核心业务模块拆分以及负责开发一些与平台运营相关的系统.</p><h2 id=集合>集合</h2><ol><li>List | ArrayList | LinkedList | CopyOnWriteArrayList</li><li>Set | HashSet | LinkedHashSet | TreeSet</li><li>Queue | PriorityQueue | BlockingQueue | DelayQueue</li><li>Map | HashMap | LinkedHashMap | ConcurrentHashMap</li></ol><h2 id=多线程>多线程</h2><ol><li>线程的生命周期和状态</li><li>死锁 | 避免死锁</li><li>Java 内存模型</li><li>volatile</li><li>乐观锁与悲观锁</li><li>synchronized</li><li>ReentrantLock | Condition</li><li>ReentrantReadWriteLock | StampedLock</li><li>ThreadLocal</li><li>线程池 | ThreadPoolExcutor | 参数</li><li>常见并发容器</li><li>AQS | 常见同步工具类<ul><li>Semaphore (permits accquire(permits&ndash;) release(permits++) ) 使用场景：控制并发访问量和单机限流</li><li>CountDownLatch (count countdown(count&ndash;) await(count==0)) 使用场景：并行任务和同步操作</li><li>CyclicBarrier (parties await)
使用场景：主要应用场景和 <code>CountDownLatch</code> 类似</li></ul></li><li>Atomic | CAS算法 Unsafe.compareAndSwap native</li><li>CompletableFuture</li></ol><h2 id=jvm>JVM</h2><ol><li><p>内存区域</p><ul><li>堆 + 字符串常量池 (对象实例 + 字符串)</li><li>程序计数器 (1. 字节码解释器改变程序计数器来依次读取指令,实现流程控制 2. 记录线程执行的位置)</li><li>栈 (栈帧&ndash;> 局部变量表 + 操作数栈(中间计算结果) + 动态链接(调用其他方法时,将符号引用转化为直接引用) +
方法返回地址)</li><li>本地方法栈 (native方法 同栈帧)</li><li>方法区(元空间(类信息 + 字段信息 + 方法信息 + 静态变量 + 常量 + JIT编译后的代码缓存) + 运行时常量池(类符号引用 +
字段符号引用 + 方法符号引用 + 接口方法符号))</li><li>本地内存</li></ul></li><li><p>类创建过程</p><ol><li><p>加载(类加载器加载)</p></li><li><p>连接</p><ul><li><p>验证(验证 class文件格式检查 字节码语义检查 程序语义检查 类正确性检查)</p></li><li><p>准备(分配内存 初始化零值 设置对象头(类的元数据 哈希码 GC分代年龄 是否启用偏向锁))</p></li><li><p>解析(将运行时常量池符号引用替换为直接引用,得到类、字段、方法在内存中的指针或偏移量)</p></li></ul></li><li><p>初始化(clinit() 调用构造方法)</p></li><li><p>卸载(类的class对象被GC)</p><ul><li>实例对象被GC</li><li>没有被引用</li><li>类加载器被GC (BootstrapClassLoader,ExtClassLoader,AppClassLoader 不会被GC)</li></ul></li></ol></li><li><p>死亡对象判断算法 (引用计数 + 可达性分析)</p><ul><li><p>GC ROOTS对象：</p><ul><li>成员对象</li><li>静态对象</li><li>常量对象</li><li>实例对象</li><li>同步锁持有对象</li><li>native对象</li></ul></li><li><p>引用类型</p><ul><li><p>强引用 不会被GC</p></li><li><p>弱应用 被发现就会被GC</p></li><li><p>软引用 内存不足,就会被GC</p></li><li><p>虚引用 随时会被GC</p></li></ul></li></ul></li><li><p>垃圾收集算法</p><ul><li>标记 - 清除 (先标记存活对象,标记完成后后清除剩余对象)</li><li>复制 (腾出一半空间,将可用对象复制到这片空间,然后清除另一半的空间)</li><li>标记 - 整理 (标记存活对象,然后向一端移动,清理端边界以外的对象)</li></ul></li><li><p>垃圾收集器 (Serial + Serial Old | Paraller New (Paraller Scavenge + Paraller Old) | CMS (初始标记 -> 并发标记 - > 重新标记 -> 并发清除)| G1 | ZGC)</p></li><li><p>类加载过程</p><ul><li>加载 根据全类名找到二进制数据，转换成方法区结构，生成一个Class对象作为方法区入口</li><li>验证 class文件格式检查 字节码语言检查 程序语义检查 类正确性检查</li><li>准备 分配内存 初始化零值 设置对象头</li><li>解析 常量池中符号引用转化成直接引用，获取类和字段在内存中的偏移量</li><li>初始化 执行clinit方法</li><li>使用</li><li>卸载 被GC回收/该类的所有实例对象被GC/该类的类加载器的实例被GC/该类没有被任何地方引用</li></ul></li><li><p>类加载器 | 破坏双亲委派</p></li><li><p>JVM参数 以及 线上排查问题思路</p><ul><li><p>GC日志记录</p><ul><li><code>-XX:+PrintGCDetails</code>：打印基本 GC 信息</li><li><code>-XX:+PrintGCDateStamps</code>：打印 GC 日期信息</li><li><code>-XX:+PrintTernuringDistribution</code>：打印对象分布</li><li><code>-XX:+PrintHeapAtGC</code>：打印堆数据</li><li><code>-XX:+PrintReferenceGC</code>：打印Reference处理信息</li><li><code>-XX:+PrintGCApplicationStoppedTime</code>：打印Stop The World的时间</li><li><code>-XX:+PrintSafepointStatistics</code>：打印safepoint信息</li><li><code>-XX:PrintSafepointStatisticsCount=1</code>：1个safepoint</li><li><code>-Xloggc:/path/to/gc-%t.log</code>：GC日志输出文件的文件路径</li><li><code>-XX:+UseGCLogFileRotation</code>：开启日志文件分割</li><li><code>-XX:NumberOfGCLogFiles=14</code>：最多分割几个文件，超过之后就从头开始写</li><li><code>-XX:GCLogFileSize=50M</code>：每个文件大小上限</li></ul></li><li><p>处理OOM</p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code> ：遇到OOM时将heap转储到物理文件中</li><li><code>-XX:HeapDumpPath=./java_pid&lt;pid>.hprof</code>：写入文件的路径</li><li><code>-XX:OnOutOfMemoryError="&lt; cmd args >;&lt; cmd args >"</code>：当内存不足时会执行命令</li><li><code>-XX:+UseGCOverheadLimit</code>：限制GC花费的VM时间比例</li></ul></li><li><p>线上示例</p><ul><li><p>设置应用的元空间大小、堆内存大小、新生代大小、栈大小、Eden区和Survivor区比例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> <span class=nv>JAVA_OPTS</span><span class=o>=</span><span class=s2>&#34;-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms512m -Xmx512m -Xmn128m -Xss256k -XX:SurvivorRatio=8&#34;</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>以服务器模式启动、禁止系统调用System.gc()、使用ParNewGC为新生代垃圾回收器、CMS为老年代垃圾回收器、老年代使用的空间达到
70% 时就开始垃圾回收、 CMS 垃圾回收时卸载不再需要的类、并行处理软引用、弱引用和虚引用、在 CMS 的 remark 阶段之前进行一次
young generation 垃圾回收、出现内存溢出错误时导出堆信息、打印垃圾回收的详细信息，包括每次垃圾回收的详细情况、时间戳、堆的情况、应用暂停的时间等</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> <span class=nv>JAVA_FIXED_ARGS</span><span class=o>=</span><span class=s2>&#34;-server -XX:+DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSInitiatingOccupancyOnly\
</span></span></span><span class=line><span class=cl><span class=s2> -XX:CMSInitiatingOccupancyFraction=70 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses -XX:+CMSClassUnloadingEnabled\
</span></span></span><span class=line><span class=cl><span class=s2> -XX:+ParallelRefProcEnabled -XX:+CMSScavengeBeforeRemark -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails\
</span></span></span><span class=line><span class=cl><span class=s2> -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps&#34;</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>设置JVM错误文件的路径地址(%p = pid)、发生OOM转储文件的路径、垃圾回收日志的路径(%t=timestamp)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> <span class=nv>JAVA_GC_LOG_PATH</span><span class=o>=</span><span class=s2>&#34;-XX:ErrorFile=/var/applog/gc/starfish-info-backend/hs_err_pid%p.log -XX:HeapDumpPath=/var/applog/gc/starfish-info-backend\
</span></span></span><span class=line><span class=cl><span class=s2> -Xloggc:/var/applog/gc/starfish-info-backend/gc%t.log&#34;</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>设置环境变量为生产环境</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> <span class=nv>PARAMS</span><span class=o>=</span><span class=s2>&#34;--spring.profiles.active=prod&#34;</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Dockerfile启动java进程的命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENTRYPOINT</span> <span class=o>[</span><span class=s2>&#34;sh&#34;</span>, <span class=s2>&#34;-c&#34;</span>, <span class=s2>&#34;java -Dloader.path=/app/libs/ -Djava.security.egd=file:/dev/./urandom -Dfile.encoding=UTF-8\
</span></span></span><span class=line><span class=cl><span class=s2> </span><span class=nv>$JAVA_OPTS</span><span class=s2> </span><span class=nv>$JAVA_FIXED_ARGS</span><span class=s2> </span><span class=nv>$JAVA_GC_LOG_PATH</span><span class=s2> -jar /app/app.jar </span><span class=nv>$PARAMS</span><span class=s2>&#34;</span><span class=o>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul></li></ol><p>堆结构:</p><div class=table-wrapper><table><thead><tr><th>新生代</th><th>老年代</th><th>元空间</th><th>本地内存</th></tr></thead><tbody><tr><td>Eden | S0 |S1</td><td>Ternured</td><td>MetaSpace(初始20.8m)</td><td>代码缓存 + Thread (线程私有)</td></tr><tr><td>-XX:NewSize=2048M</td><td></td><td></td><td></td></tr><tr><td>-XX:MaxNewSize=3096M</td><td></td><td></td><td></td></tr><tr><td>-Xmn2048m</td><td></td><td></td><td></td></tr><tr><td>-XX:NewRatio=1 (老年代:新生代 = 1:1)</td><td></td><td></td><td></td></tr><tr><td>-Xms8G</td><td>-Xms8G</td><td></td><td></td></tr><tr><td>-Xmx8G</td><td>-Xmx8G</td><td></td><td></td></tr><tr><td></td><td></td><td>-XX:MetaspaceSize=512m</td><td></td></tr><tr><td></td><td></td><td>-XX:MaxMetaspaceSize=512m</td><td></td></tr><tr><td></td><td></td><td></td><td>-Xss256k（栈大小）</td></tr></tbody></table></div><h2 id=spring-spring-mvc-springboot>Spring Spring MVC SpringBoot</h2><ol><li><p>Spring IOC & Spring AOP</p><ul><li>IOC: 将创建对象的控制权交给Spring容器</li><li>AOP: 在程序执行过程中动态织入代码,实现对横切关注点的模块化管理</li></ul></li><li><p>Spring 核心流程图 （创建Bean过程）</p><ol><li>根据注解或配置文件获取Bean的定义</li><li>通过反射创建Bean的实例</li><li>通过set方法设置属性</li><li>如果实现了BeanNameAware|BeanClassLoaderAware|BeanFactoryAware接口，则调用对应的set方法</li><li>如果实现了BeanPostProcessor接口，则调用postProcessorBeforeInitialization()方法</li><li>如果实现了InitializingBean接口,则调用afterPropertiesSet方法</li><li>如果指定了init-method方法，则执行指定方法</li><li>如果实现了BeanPostProcessor接口，则调用postProcessorAfterInitialization()方法</li><li>使用Bean</li><li>如果实现了DisposableBean接口，则调用destory()方法</li><li>如果指定了destory-method方法，则执行指定方法</li></ol></li><li><p>Spring AOP通知方式</p><ul><li>前置通知</li><li>后置通知</li><li>返回通知</li><li>异常通知</li><li>环绕通知</li></ul></li><li><p>Spring 管理事务方式| 隔离级别 | 传播行为</p><ul><li>事务管理方式：<ul><li>编程式： TransacationManager手动提交</li><li>声明式： xml|注解 (@Transactional) 自动提交</li></ul></li><li>隔离级别：<ul><li>采用数据库的隔离级别 (Default)</li><li>读未提交 (Read Uncommited)</li><li>读已提交 (Read Commited)</li><li>可重复读 (MySQL数据库的默认隔离级别 Repetable Read)</li><li>串行化 (Serializable)</li></ul></li><li>传播行为：<ul><li>Requried：必须要有一个事务,没有就创建</li><li>Requried_New：必要需要有一个事务,有也创建</li><li>Support: 可以有一个事务,没有就以非事务运行</li><li>Not_Support: 有没有都以非事务运行</li><li>Mandatory: 必须要有一个事务,没有就抛异常</li><li>Never: 绝对不能有事务,有就抛异常</li><li>Nested: 有就嵌套事务,没有就创建</li></ul></li></ul></li><li><p>Spring MVC 流程</p><ol><li>客户端请求,DispatcherServlet拦截请求</li><li>DispatcherServlet调用HandlerMapping,HandlerMapping根据请求路径找到对应的Handler</li><li>DispatcherServlet调用HandlerAdapter执行Handler</li><li>Handler处理完请求后,返回ModelAndView给DispatcherServlet,Model是返回的数据对象,View是逻辑视图</li><li>DispatcherServlet调用ViewResolver对逻辑视图进行解析,找到真正的视图</li><li>DispatcherServlet把返回的Model传给视图进行渲染</li><li>把渲染后的视图返回响应</li></ol></li><li><p>SpringBoot 常用注解 自动装配原理</p><p>常用注解： @SpringBootApplication (@ComponetScan @Configuration @EnableAutoConfiguration = @Import(
AutoConfigurationImportSelector))</p><p>自动装配原理:
SpringBoot通过@EnableAutoConfiguration注解实现了自动装配,@EnableAutoConfiguration通过AutoConfigurationImportSelector的getAutoConfigurationEntry方法,使用SpringFactoryLoader加载META-INF/Spring.factories文件,获取EnableAutoConfiguration指定的类,并过滤掉不满足Condition的类,实现自动装配.</p></li><li><p>什么是SpringBootStarter 自定义Starter</p><ul><li>starter是为SpringBoot提供一套快速的默认配置的机制，使用SpringFactoryLoader实现.</li><li>实现自定义starter需要: 1.导入Spring依赖 2.自定义配置类 3.编写META-INF/spring.factories，指定enableAutoConfiguration要加载的类</li></ul></li><li><p>spring循环依赖怎么解决（说出三级缓存源码细节）</p><ol><li>SingletonObjects 一级缓存 存放成品Bean</li><li>EarlySingletonObjects 二级缓存 存放过渡Bean包括原始Bean和代理Bean</li><li>SingletonFactories 三级缓存 存放ObjectsFactory对象,实际使用getEarlyBeanReference()方法获取原始Bean或代理Bean</li></ol></li></ol><blockquote><p>如果是只有两级缓存,代理Bean每次生成的对象会不一样,不满足Spring单例原则.</p><p>2.6.X版本默认关闭循环依赖,如需开启在配置文件中指定spring.main.allow-circular-references=true</p><p>前置条件:对象是单例的且开启了循环依赖,默认会将未初始化完成的Bean放入三级缓存中,循环依赖的对象会从三级缓存中找到依赖的对象,并在三级缓存销毁,放入二级缓存中.等初始化完成就从二级缓存中销毁,放入一级缓存中.</p></blockquote><h2 id=mysql>MySQL</h2><ol><li>MySQL基础架构<ul><li>连接器</li><li>查询缓存</li><li>分析器</li><li>优化器</li><li>执行器</li><li>存储引擎</li></ul></li><li>MySQL存储引擎<ul><li>MyISAM | InooDB 区别如下<ul><li>MyISAM不支持事务，InooDB支持事务</li><li>MyISAM和InooDBd都使用B+树作为数据结构，但实现方式不一样</li><li>MyISAM只有表锁，InooDB有行锁，表锁，读锁，写锁，MVCC等</li><li>MyISAM只有非聚簇索引，InooDB既有聚簇索引也有非聚簇索引</li><li>MyISAM不支持外键，InooDB支持外键</li><li>MyISAM不支持崩溃恢复，InooDB可以依赖redo log恢复数据</li></ul></li></ul></li><li>MySQL索引<ul><li>聚簇索引 | 非聚簇索引</li><li>主键索引 | 普通索引,唯一索引,外键索引,联合索引,全文索引</li></ul></li></ol><blockquote><ul><li>最左前缀匹配原则： 使用联合索引时，有最左匹配原则，即从左往右，依次匹配</li><li>索引下推： 即将查询条件进行优化，直接过滤掉不满足条件的记录</li><li>为什么选择B+树作为索引的数据结构，有什么优点: IO查询稳定,范围查询更快.</li><li>一个高度为3的B+树最多能存多少条记录:</li></ul><p>​ 记录数 = 根节点指针数 * 单个叶子节点记录数
​ = 16<em>1024/(6(InnoDB指针大小)+4(int主键大小)/8(bigint主键大小)) * (16kb(页大小)/1kb(单条数据最大长度))
​ = 16</em>1024/10(14) (一层容量指针数) * 16*1024/10(14) (二层容量指针数) * 16
​ = 1170 * 1170 * 16
​ = 21,902,400</p><ul><li>如果走辅助索引,最多需要经过几次IO: 3层 找到主键 再3层 找到数据 = 6次</li></ul></blockquote><ol start=4><li>MySQL日志<ul><li>undo log<ul><li>存放所有事务进行修改前的原始数据</li><li>用于保证事务的原子性,另外MVCC的实现依赖于:隐藏字段和Read View以及undo log.</li></ul></li><li>redo log<ul><li>用于保证数据库的持久性,会先通过buffer pool去读或修改数据,然后记录到redo log上,等待刷盘.</li><li>存在刷盘机制,0-提交事务不刷盘,等待后台线程刷盘 1-提交事务就刷盘 2-提交事务写入文件缓存,等待后台线程刷盘</li></ul></li><li>bin log<ul><li>用于数据库备份,会记录所有涉及更新数据的逻辑操作.</li></ul></li></ul></li></ol><blockquote><p>为了解决写入redo log和bin log可能会出现不一致的情况，Mysql使用两阶段提交方案解决这个问题.</p><ol><li>在尚未提交事务时,会先prepare记录redo log.</li><li>在已提交事务时,会先写入bin log日志,然后在redo log日志进行commit,提交写入redo log.</li><li>即使在提交事务时,写入bin log发生异常,也不会有影响,只会回滚事务.</li><li>在写入redo log时发生异常,不会回滚事务,而是通过找到bin log来写入数据.</li></ol></blockquote><ol start=5><li><p>MySQL事务</p><ul><li>特性: C是目的，AID是手段<ul><li>A 原则性</li><li>C 一致性</li><li>I 隔离性</li><li>D 持久性</li></ul></li><li>并发问题:<ul><li>丢失修改: 修改操作被覆盖了</li><li>脏读: 读到了未提交的数据</li><li>不可重复读：两次读结果不一样</li><li>幻读： 两次读的结果变多了</li></ul></li><li>解决方案：<ul><li>锁<ul><li>读锁（共享锁）</li><li>写锁（排他锁）</li><li>表锁</li><li>行锁</li></ul></li><li>MVCC： 多版本并发控制，版本号唯一，使用隐藏字段、Read View、Undo log实现</li></ul></li><li>事务隔离级别： 使用锁和MVCC共同实现<ul><li>读未提交： 解决丢失修改</li><li>读已提交： 解决了丢失修改，脏读</li><li>可重复读： 解决了丢失修改，脏读，不可重复读</li><li>串行化： 解决了丢失修改，脏读，不可重复读，幻读</li></ul></li></ul></li><li><p>MySQL锁</p><ul><li><p>读锁（共享锁）： 锁兼容,读取时多个事务可同时获取. 一般不加锁，除非显式指定了 select &mldr; lock in share mode / select &mldr; for share</p></li><li><p>写锁（排他锁）: 锁不兼容,修改时只能由一个事务获取. 一般不加锁，除非显式指定了 select &mldr; for update</p></li><li><p>表锁： 针对非索引字段加锁</p></li><li><p>行锁： 针对索引字段加锁</p><ul><li><p>记录锁： Record Lock,单行记录上锁</p></li><li><p>间隙锁： Gap Lock,多行记录上锁但不包括本身</p></li><li><p>临键锁： Next-Key Lock = Record Lock + Gap Lock,多行记录上锁包括本身</p></li></ul></li></ul></li></ol><blockquote><p>RR的事务隔离级别下，行锁默认使用临键锁，但操作主键索引或唯一键索引时，会降级成记录锁</p><p>快照读： 即普通的select 语句，不加锁，读的是记录的历史版本.</p><p>当前读： 即加了读写锁的select 语句，读的是记录的当前版本.</p></blockquote><ol start=7><li>MVCC实现<ul><li>读： 读当前事务开始时间的版本数据<ul><li>写： 创建一个新的版本，写入版本数据</li><li>在RR隔离级别下，如果是当前读（一致性锁定读）的情况下(for update/ insert / update / delete)，通过加入临键锁，锁住当前记录和范围，防止其他事务插入数据，出现幻读</li><li>但如果是快照读（一致性非锁定读），即使是RR隔离级别，也会出现幻读</li></ul></li></ul></li></ol><ul><li><p>实现方式： 隐藏字段 、 Read View 、 undo log</p><ul><li><p>隐藏字段</p><ul><li>DB_TRX_ID : 最后一次插入或更新该行的事务id</li><li>DB_ROW_ID: 没有设置主键且没有唯一非空索引时，使用它来充当聚簇索引</li><li>DB_ROLL_PTR: 回滚指针,指向undo log</li></ul></li><li><p>Read View</p><ul><li>可见性判断,里面保存了"当前对本事务不可见的其他活跃性事务"<ul><li>m_low_limit_id: 目前出现过的最大的事务的ID+1,即下一个被分配事物的ID,大于等于这个ID的数据版本均不可见</li><li>m_up_limit_id: 活跃事务列表m_ids中最小的事务ID,如果m_ids为空,则等价于m_low_limit_id.小于这个ID的数据版本均可见</li><li>m_ids: Read View 创建时其他未提交的活跃事务的ID列表.创建Read
View时,将当前未提交事务的ID记录下来,后续即使他们修改了记录行的值,对当前事务也是不可见的.m_ids不包括当前事务自己和已提交的事务.</li><li>m_creator_trx_id: 创建该Read View的事务ID.</li></ul></li></ul></li><li><p>undo log</p><ul><li>用于事务回滚，恢复到修改前的样子</li><li>用于MVCC，读历史版本的数据，实现一致性非锁定读</li></ul></li></ul></li><li><p>数据可见性算法 ： &mldr;</p></li><li><p>不可重复读问题:</p><ul><li>RC: 每次读都会有新的Read View记录,有不可重复读问题</li><li>RR: 事务开始时,只有第一次读有Read View记录,所以没有不可重复读问题</li></ul></li><li><p>幻读问题:</p><ul><li>RR: 加入临键锁,解决幻读问题</li></ul></li></ul><ol start=8><li><p>MySQL执行计划分析</p><ul><li>explain + SQL<ul><li>id： 查询序号</li><li>select_type： 查询类型，用于区分普通查询，联合查询，子查询等<ul><li>SIMPLE： 简单查询，不含UNION或子查询</li><li>PRIMARY： 如果存在子查询，外层的SELECT标记为PRIMARY</li><li>SUBQUERY： 子查询中的第一个SELECT</li><li>UNION： 联合查询</li><li>DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED</li><li>UNION RESULT： UNION的查询结果</li></ul></li><li>table：查询表名</li><li>partitions：匹配分区</li><li>type（重要）：表的访问方法<ul><li>system：表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例</li><li>const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件</li><li>eq_ref： 当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join
方式，常用于使用主键或唯一索引的所有字段作为连表条件</li><li>ref： 使用普通索引作为查询条件，查询结果可能找到多个符合条件的行</li><li>fulltext</li><li>ref_or_null</li><li>index_merge： 当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引</li><li>unique_subquery</li><li>index_subquery</li><li>range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了</li><li>index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快</li><li>ALL：全表扫描</li></ul></li><li>possible_keys：查询可能用到的索引，null则可能没用到索引</li><li>key（重要）：实际用到的索引，null则没用到索引</li><li>key_len：索引最大长度，key=null那key_len=null</li><li>ref：当使用索引等值查询时，与索引作比较的列或常量</li><li>rows：大致需要读取的行数，越小越好</li><li>filtered：条件过滤后的留存记录百分比</li><li>Extra（重要）：查询的额外信息<ul><li>Using filesort: 排序时使用了外部索引进行排序，没用到内部索引进行排序</li><li>Using temporary： 创建临时表来存储查询结果，常见于order by 或 group by</li><li>Using index: 使用了覆盖索引，不用回表，查询效率非常高</li><li>Using index condition： 查询优化器使用到了索引下推这个特性</li><li>Using where： 使用where条件进行了过滤，一般在没用到索引时出现</li><li>Using join buffer： 连表查询</li></ul></li></ul></li></ul></li><li><p>MySQL优化</p><ul><li><p>避免隐式转换，隐式转换(两边数据类型不一致)会导致索引失效</p></li><li><p>避免使用select * 而是使用 select 字段</p></li><li><p>避免过多join表，不超过5个</p></li><li><p>选择合适的字段类型</p></li><li><p>避免出现大事务，拆分成小事务分批提交</p></li><li><p>正确使用索引</p></li><li><p>深度分页使用范围查询、子查询、延迟关联优化</p></li><li><p>使用连续自增主键，而不是使用uuid(uuid范围查询无法排序)</p></li></ul></li></ol><h2 id=redis>Redis</h2><ol><li><p>Redis为什么快</p><ul><li>基于内存,访问快</li><li>基于Reactor模型开发了一套事件处理模型，主要是单线程事件循环和IO多路复用</li><li>内部使用了多种优化后的数据类型,效率高</li></ul></li><li><p>常见的读写缓存策略</p><ul><li>旁路缓存模式（应用程序直接与「数据库、缓存」交互，并负责对缓存的维护）<ul><li>读：先从缓存读，读不到由「应用程序」从数据库读取数据后返回，再把数据放入缓存</li><li>写：写入数据库，删掉缓存（服务端写）</li></ul></li><li>读写穿透模式（应用程序与「缓存」交互，「缓存」与「数据库」交互,负责缓存的维护）<ul><li>读：先从缓存读，读不到由「缓存」从数据库读，并将结果放入缓存,返回数据给应用</li><li>写：写入缓存，缓存不存在则更新数据库，存在则更新缓存,由「缓存」自己写数据库</li></ul></li><li>异步缓存写入 (应用程序与「缓存」交互，「缓存」与「数据库」交互,负责缓存的维护)<ul><li>读：先从缓存读，读不到从数据库读，再放入缓存后返回</li><li>写：写入缓存，不更新db,改为异步批量更新db</li></ul></li></ul></li><li><p>Redis应用场景</p><ul><li>分布式锁</li><li>限流</li><li>消息队列</li><li>延时队列</li><li>分布式session</li></ul></li><li><p>Redis线程模型</p><ul><li>读写单线程，异步删除、网络请求多线程</li><li>基于Reactor模式开发了一套文件事件处理器，以单线程方式运行，以I/O多路复用来监听多个套接字<ul><li>文件事件处理器<ul><li>多个socket（客户端连接）</li><li>I/O多路复用程序（支持多个连接）</li><li>文件事件分派器（将socket关联到事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul></li></ul></li></ul></li><li><p>Redis数据结构以及应用场景</p><ul><li><p>String</p><ul><li><p>结构特点</p></li><li><p>SDS(Simple Dynamic String)实现，好处在于</p><ul><li>可以扩容，避免缓冲区异常</li><li>获取字符串长度复杂度为O(1)</li><li>减少内存分配次数</li><li>二进制安全</li></ul></li><li><p>使用场景</p></li><li><p>存储token/session/userId，序列化后的对象等</p><ul><li>实现分布式锁(setnx key value)</li></ul></li></ul></li><li><p>List</p><ul><li>结构特点<ul><li>双向链表，支持反向查找和遍历</li></ul></li><li>使用场景<ul><li>最新文章、最新动态</li></ul></li></ul></li><li><p>Set</p><ul><li>结构特点<ul><li>无序集合，类似Java中的HashSet</li></ul></li><li>使用场景<ul><li>网站UV统计，文章点赞/已读统计，关注</li><li>抽奖系统</li></ul></li></ul></li><li><p>Sorted Set(Zset)</p><ul><li>结构特点<ul><li>类似TreeSet和HashMap的结合,但增加了个权重参数score,使得可以排序，还可以根据score范围查询</li></ul></li><li>使用场景<ul><li>排行榜</li></ul></li></ul></li><li><p>BitMap</p><ul><li>结构特点<ul><li>key是元素本身，value是0/1，是一个存储0/1的数组，每个value占一个bit位</li></ul></li><li>使用场景<ul><li>用户签到情况、活跃用户情况、是否点赞/关注</li></ul></li></ul></li><li><p>HyperLogLog（基数统计）</p><ul><li>结构特点<ul><li>基数计数概率算法，并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）</li></ul></li><li>使用场景<ul><li>热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计</li></ul></li></ul></li><li><p>Geospatial</p><ul><li>结构特点<ul><li>存储地理位置信息，基于 Sorted Set 实现</li></ul></li><li>使用场景<ul><li>附近的人</li></ul></li></ul></li></ul></li><li><p>Redis持久化机制</p><ul><li>快照（snapshotting,RDB）<ul><li>是Redis默认持久化方式，通过创建快照来获取数据在某个时间点的副本</li><li>默认使用bgsave进行持久化，通过创建子线程执行，而save操作会阻塞主线程</li></ul></li><li>追加读（append-only file,AOF）<ul><li>每条更改数据的命令会先放入缓冲区(server.aof_buf)，然后写入AOF文件，最后通过fsync策略来决定何时同步到硬盘.</li><li>AOF工作流程<ul><li>命令追加（append）: 写命令放入AOF缓冲区</li><li>文件写入（write）：将AOF缓冲区的数据写入系统内核缓冲区</li><li>文件同步（fsync）：AOF缓存区根据fsync策略向磁盘做同步操作，写入AOF文件</li><li>文件重写（rewrite）：AOF文件越来越来，需要定期重写来压缩AOF文件</li><li>重新加载（reload）: 通过加载AOF文件来恢复数据</li></ul></li><li>fsync策略<ul><li>appendfsync always:
主线程调用write执行完成后，后台线程（aof_fsync线程）立马调用fsync函数进行同步 (<code>write + fsync</code>)</li><li>appenfsync eversec:
主线程调用write执行完成后，后台线程（aof_fsync线程）每秒调用fsync函数进行同步(<code>write + 1秒 + fsync</code>)</li><li>appendfsync
no：主线程调用write执行完成后，由操作系统决定什么时候调用fsync函数进行同步（<code>write 不 fsync ,操作系统决定,Linux一般是30秒</code>）</li></ul></li><li>rewrite<ul><li>通过读取当前数据库的状态，然后生成一个新的AOF文件来替换旧的AOF文件</li><li>同时维护了一个AOF重写缓冲区,以记录创建过程中出现的写命令,等创建完成后,将写命令追加到新的AOF文件中</li><li>通过<code>BGREWRITEAOF</code>命令来触发重写操作,会创建一个子线程进行重写操作</li></ul></li></ul></li><li>混合（RDB+AOF）<ul><li>使用<code>aof-use-rdb-preamble</code>命令开启混合持久化,AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头,但会导致可读性较差.</li></ul></li><li>如何选择持久化<ul><li>数据安全性要求高,选择RDB+AOF同时开启或者混合模式</li><li>数据安全性要求不高时,选择RDB</li><li>不建议只开启AOF,不易备份或快速重启恢复</li></ul></li></ul></li><li><p>Redis内存管理策略</p><ul><li>过期数据存储方式<ul><li>通过字典(redisDb)来存储key的过期时间,由dict属性存储键值对,expires属性存储过期时间</li></ul></li><li>过期数据删除策略<ul><li>惰性删除<ul><li>用到key时检查,是否需要删除.但会导致堆积过多过期key</li></ul></li><li>定期删除<ul><li>隔一段时间抽取一批key检查,是否需要删除.</li></ul></li></ul></li><li>内存淘汰机制<ul><li>volatile-lru: 淘汰最近最少使用的数据 (已设置过期时间)</li><li>volatile-ttl: 淘汰要过期的数据 (已设置过期时间)</li><li>volatile-random: 随机淘汰数据 (已设置过期时间)</li><li>allkeys-lru: 内存不足时,淘汰最近最少的数据 (全部)</li><li>allkyes-random: 内存不足时,随机淘汰数据 (全部)</li><li>no-eviction: 禁止写入数据</li><li>volatile-lfu: 淘汰最不经常使用的数据 (已设置过期时间)</li><li>allkeys-lfu: 淘汰最不经常使用的数据 (全部)</li></ul></li></ul></li><li><p>Redis生产问题</p><ul><li>缓存穿透<ul><li>访问大量无效key,透过缓存,直接请求数据库</li><li>解决方案<ul><li>缓存无效key</li><li>布隆过滤器</li><li>接口限流,IP黑名单</li></ul></li></ul></li><li>缓存击穿<ul><li>缓存的热点数据过期或不存在,大量请求数据库</li><li>解决方案<ul><li>缓存key时间设置比较长</li><li>提前预热热点数据</li></ul></li></ul></li><li>缓存雪崩<ul><li>同一时间,大量缓存数据失效,大量请求数据库</li><li>解决方案<ul><li>多级缓存</li><li>限流</li><li>缓存预热</li></ul></li></ul></li><li>缓存数据库一致性<ul><li>旁路缓存模式: 先更新数据库,再删缓存.</li><li>增加缓存更新重试机制: 隔断时间重试删除缓存,或者引入消息队列来删缓存(删除缓存消息写入mq,mq来重试删除.)</li></ul></li></ul></li><li><p>Redis集群</p><ul><li>Redis 多集群：主从模式,一主多从 （端口：6379）<ul><li>优点: 简单</li><li>缺点: 需要手动维护主节点信息,发生故障需要手动恢复</li></ul></li><li>Redis Sentinel：哨兵模式,一主多从,三哨兵 （端口：26379）<ul><li>优点: 在主从模式的基础上,增加哨兵节点,以维护Redis节点状态,自动故障转移</li><li>缺点: 不好动态扩容</li><li>常见问题<ul><li>有什么作用<ul><li>监控：监控所有Redis节点状态</li><li>故障转移：如果master出现异常，Sentinel会实现故障转移，将一台slave升级成master</li><li>通知：通知新的master连接信息给slave，让它们执行replicaof成为新的master的slave</li><li>配置提供：通知新的master连接信息给客户端</li></ul></li><li>检测节点是否下线<ul><li>主观下线：某个Sentinel节点认为Redis节点下线（PING请求，PONG(LOADING/MASTERDOWN)超过响应时间）</li><li>客观下线：超过半数Sentinel节点认为Redis节点下线</li></ul></li><li>如何选举新的master节点<ol><li>slave在线: 节点必须在线</li><li>slave优先级：通过slave-priority设置优先级，最高的成为master,没有优先级就看复制进度</li><li>复制进度：数据最完整，复制进度最快的slave成为master</li><li>runid: 如果优先级和复制进度一样，则runid最小的成为master</li></ol></li><li>Sentinel如何选举Leader<ul><li>通过Raft算法选举出Leader</li></ul></li><li>Sentinel可以防止脑裂吗<ul><li>发生网络隔离（也就是脑裂）时，master必须能写入slave，并能从节点得到响应。否则就拒绝接受新的写入命令</li></ul></li></ul></li></ul></li><li>Redis Cluster：切片集群,三主三从（端口：6379和16379）<ul><li>优点: 官方推荐,提供主从复制、故障转移功能,很⽅便地进⾏横向拓展,动态扩容和缩容是其最⼤的优势</li><li>缺点: 需要多服务器,适合数据量大,并发量⼤的场景</li><li>常见问题<ul><li>如何分片<ul><li>Redis使用哈希槽分区,每个键值对属于一个哈希槽.<code>哈希槽 = key ^ CRC-16 % 16384</code></li></ul></li><li>如何找到对应的哈希槽<ul><li>根据Key通过上面的计算公式找到对应的哈希槽,然后再查询哈希槽和节点的映射关系</li><li>如果是当前节点负责就返回响应结果</li><li>如果不是则发送重定向错误,告诉客户端当前的哈希槽由哪个节点负责</li><li>客户端则向目标节点发送请求并更新缓存的哈希槽分配信息</li></ul></li><li>为什么哈希槽是16384个(2^14)<ul><li>哈希槽太大会导致心跳包变大,消耗带宽</li><li>哈希槽总数越少,对存储的哈希槽信息的bitmap压缩效果好</li><li>16384个槽节点占用空间2k(16384/8),空间小,并且不太会超过1000个主节点,完全够用</li></ul></li><li>Redis Cluster 扩容缩容<ul><li>扩容缩容的本质是重新分片,动态迁移哈希槽</li><li>提供重定向机制(ASK|MOVED),在发生扩容缩容时,仍能对外提供服务</li></ul></li><li>Redis Cluster 节点通信<ul><li>Cluster 各个节点使用Gossip协议通信,每个节点都维护了一份集群的状态信息</li><li>Cluster 内置了Sentinel机制,通过Gossip协议相互探测健康状态,发生故障自动切换</li></ul></li></ul></li></ul></li></ul></li></ol><blockquote><p>一致性哈希：</p></blockquote><h2 id=分布式>分布式</h2><ol><li><p>分布式共识算法</p><ul><li>CAP理论<ul><li>C|Consistency: 一致性, 所有节点访问同一份最新的数据副本</li><li>A|Availability: 可用性, 非故障节点在合理时间返回合理的响应</li><li>P|Partition Tolerance: 分区容错性,当出现网络分区时,仍能对外提供服务</li><li>一般时CP或AP架构,当发生网络分区时,P是一定需要保证的.选择CP还是AP就看业务场景</li><li>但没有发生网络分区时,CA是能同时保证的.</li><li>CP架构: ZooKeeper | AP架构: Eureka | CP&amp;AP架构: Nacos</li></ul></li><li>BASE理论<ul><li>BA|Basically Available：基本可用, 允许损失部分可用性</li><li>S|Soft-state：软状态, 允许系统存在中间状态,且不会影响系统整体可用性</li><li>E|Eventually Consistent：最终一致性, 系统中的所有数据副本在经过一段时间同步后,最终会达到一致的状态.</li><li>当发生网络分区时，要保证AP时，会放弃C，而BASE理论则是不保证强一致性，但要保证最终一致性.是对AP方案的补充.</li></ul></li><li>Paxos算法<ul><li>Basic Paxos：多节点就value达成共识<ul><li>三种角色<ul><li>提议者：接受客户端请求，发起提案（提案ID和提案value）</li><li>接受者：对提案进行投票，同时记住投票历史</li><li>学习者：超过半数投票的提案将会被执行运算，并发送给客户端</li></ul></li></ul></li><li>Multi Paxos：执行多个Basic Paxos</li></ul></li><li>Raft算法<ul><li>拜占庭将军：在会出现故障或叛变节点时，需要保证系统的整体可用性</li><li>共识算法：即使面对故障，服务器也可以在共享状态上达成一致</li><li>基础<ul><li>节点类型：某一时间，节点一定会是以下的身份类型<ul><li>Leader：负责发起心跳，响应客户端，创建日志，同步日志</li><li>Candidate：发起竞选（Follower竞争Leader产生的临时角色）</li><li>Follower：接受Leader的心跳和日志同步数据，投票给Candidate</li></ul></li><li>任期：每次选举的开始就是一次任期（term），如果没有选出Leader将会开启下个任期和选举</li><li>日志：<ul><li>log = entry&lt;term,index,cmd>[] ;</li><li>日志由entry数组构成，每一个事件成为一个entry，只有Leader可以创建entry；</li><li>term = 任期；index = enry在log中下标；cmd = 应用到状态机的操作；</li></ul></li></ul></li><li>领导人选举：<ul><li>使用心跳机制来触发选举，超过半数投票的Candidate获得选举，成为Leader</li><li>Follower会自增term号并转换状态为Candidate，并向其他节点发起RequestVoteRPC请求，直到有Leader出现或进行下一轮选举</li><li>避免出现无限重复投票的情况，采用选举随机超时策略，增加一个选举随机超时时间</li></ul></li><li>日志复制：Leader 和 Follower 的日志需要保持一致，不一致时会删除Follower不一致的地方，将Leader记录的后续日志发给Follower</li><li>安全性<ul><li>选举限制</li><li>节点崩溃</li><li>时间与可用性</li></ul></li></ul></li><li>Gossip协议：分散式发散消息<ul><li>集中式发散消息：一个节点向其他节点共享信息</li><li>分散式发散消息：每个节点周期性随机向其他节点共享信息</li><li>Redis Cluster 采用<code>Gossip</code>协议来进行共享信息，每个节点都维护了一份Redis集群的状态信息</li><li>消息传播模式<ul><li>反熵：消除不同节点的数据差异，提高节点相似度，从而降低熵值（不确定性）</li><li>传谣（谣言传播）：一个节点一旦有了新数据就成为了活跃节点，活跃节点周期性向其他节点发送新数据，直到所有节点都有了新数据</li><li>差异：<ul><li>反熵用于传播所有数据，传谣用于传播新数据</li><li>反熵一般需要设计一个闭环，传谣适合节点数量更多和动态变化的场景</li></ul></li></ul></li></ul></li></ul></li><li><p>API网关：请求转发 + 请求过滤</p><p><img src=https://oss.javaguide.cn/github/javaguide/distributed-system/api-gateway/up-35e102c633bbe8e0dea1e075ea3fee5dcfb.png loading=lazy></p><ul><li><p>Netflix Zuul</p><ul><li>Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能</li></ul></li><li><p>Spring Cloud Gateway</p><ul><li><p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能,和 Zuul 2.x
的差别不大，也是通过过滤器来处理请求</p></li><li><p>工作流程</p><ul><li>路由判断(Predicate)：先经过Gateway Handler Mapping处理，经过Predicate判断符合哪个路由规则，再映射到后端服务</li><li>请求过滤(Pre-Request)：然后请求到达Gateway Web Mapping处理，经过Filter Chain进行拦截和修改(
增加请求头、参数校验)，再转发请求到后端服务</li><li>服务处理(Handler)：后端处理请求</li><li>响应过滤(Post-Request)：后端处理请求完成后，返回给Gateway再次经过Filter Chain进行处理，再响应给客户端</li><li>响应返回：过滤处理完成后，响应给客户端</li></ul></li><li><p>Predicate</p><ul><li>断言配置：满足断言的条件后，就能映射到指定的服务</li></ul><p><img src=https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png loading=lazy></p></li><li><p>动态路由：使用Nacos Server和Spring Cloud Alibaba Nacos Config实现动态路由，自动感知配置变化，动态配置网关信息</p></li><li><p>Filter</p><ul><li><p>Pre：请求到服务前，对请求进行拦截和修改，如参数校验，权限校验，流量监控，日志输出，协议转换等</p></li><li><p>Post：请求处理完成后，对响应内容进行修改，如修改响应头、日志输出、流量监控</p></li></ul></li><li><p>限流：Sentinel 模块实现限流，提供两种资源维度的限流：route 维度和自定义 API 维度</p></li><li><p>全局异常处理：实现ErrorWebExceptionHandler的Handle方法</p></li></ul></li><li><p>OpenResty</p><ul><li>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台,通过简单的 Lua 语言来扩展网关的功能，比如实现自定义的路由规则、过滤器、缓存策略等</li></ul></li><li><p>Kong</p><ul><li>基于OpenResty（Nginx + Lua），由Kong Server、Apache Cassandra/PostgreSQL、Kong Dashboard组成，本身就是一个 Lua 应用程序</li></ul></li><li><p>APISIX</p><ul><li>基于 OpenResty 和 etcd</li></ul></li><li><p>Shenyu</p><ul><li>基于 WebFlux</li></ul></li></ul></li><li><p>分布式ID</p><ul><li>基本要求<ul><li>全局唯一：ID 全局唯一性</li><li>高性能：生成速度要快</li><li>高可用：生成服务要可用</li><li>方便易用：拿来即用</li></ul></li><li>解决方案<ul><li>数据库主键自增（MySQL、Redis）：MySQL号段模式，Redis incr指令</li><li>UUID、Snowflake（雪花算法）：生成速度快，ID有序，比较灵活但有可能出现时钟回拨导致重复ID问题</li><li>UidGenerator：对雪花算法进行了改进，QPS更高，但18年后不再维护</li><li>Leaf：支持号段模式和雪花算法，支持双号段，解决了时钟回拨问题，QPS 压测结果近 5w/s</li><li>Tinyid：基于数据库号段模式，支持双号段，纯本地操作，无 HTTP 请求消耗</li><li>IdGenerator：兼容所有雪花算法，解决了时钟回拨问题，不依赖外部存储系统，支持多语言调用</li></ul></li></ul></li><li><p>分布式锁</p><ul><li><p>基本要求</p><ul><li>互斥：任意一个时刻，锁只能被一个线程持有</li><li>高可用：当一个锁服务出现问题，能够自动切换到另外一个锁服务；即 锁一定会被释放</li><li>可重入：节点可重复获取锁</li><li>高性能：快速获取或释放锁</li><li>非阻塞：拿不到锁不能无限等待</li></ul></li><li><p>解决方案</p><ul><li><p>MySQL实现</p><ul><li>通过唯一索引或排它锁实现，但有性能差、不具备锁失效等机制</li></ul></li><li><p>Redis</p><ul><li><p><code>lua + setnx</code>指令获取简易锁</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># KEYS[1]-lockKey, ARGV[1]--requestId, ARGV[2]--expire</span>
</span></span><span class=line><span class=cl><span class=k>if</span> redis.call<span class=o>(</span><span class=s1>&#39;setNx&#39;</span>, KEYS<span class=o>[</span>1<span class=o>]</span>, ARGV<span class=o>[</span>1<span class=o>])</span> <span class=o>==</span> <span class=m>1</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> tonumber<span class=o>(</span>ARGV<span class=o>[</span>2<span class=o>])</span> &gt; <span class=m>0</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        redis.call<span class=o>(</span><span class=s1>&#39;expire&#39;</span>, KEYS<span class=o>[</span>1<span class=o>]</span>, ARGV<span class=o>[</span>2<span class=o>])</span>
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> redis.call<span class=o>(</span><span class=s1>&#39;get&#39;</span>, KEYS<span class=o>[</span>1<span class=o>])</span> <span class=o>==</span> ARGV<span class=o>[</span>1<span class=o>]</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> tonumber<span class=o>(</span>ARGV<span class=o>[</span>2<span class=o>])</span> &gt; <span class=m>0</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            redis.call<span class=o>(</span><span class=s1>&#39;expire&#39;</span>, KEYS<span class=o>[</span>1<span class=o>]</span>, ARGV<span class=o>[</span>2<span class=o>])</span>
</span></span><span class=line><span class=cl>        end
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>end
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>lua + del</code>指令释放简易锁</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span>
</span></span><span class=line><span class=cl><span class=k>if</span> redis.call<span class=o>(</span><span class=s2>&#34;get&#34;</span>,KEYS<span class=o>[</span>1<span class=o>])</span> <span class=o>==</span> ARGV<span class=o>[</span>1<span class=o>]</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> redis.call<span class=o>(</span><span class=s2>&#34;del&#34;</span>,KEYS<span class=o>[</span>1<span class=o>])</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>end
</span></span></code></pre></td></tr></table></div></div></li><li><p>Redisson：锁的优雅续期</p><ul><li>使用<code>Watch Dog</code>来监控和续期锁，执行未完成，每隔10秒就执行续期操作，将超时时间设置为30秒</li><li>内置了可重入锁、自旋锁、公平锁、多重锁、红锁、读写锁</li></ul></li></ul></li><li><p>Zookeeper</p><ul><li><p>基于<code>临时顺序节点</code>和<code>Watcher（事件监听器)</code> 实现，推荐使用 Curator 来实现 ZooKeeper 分布式锁，是Netflix开源的ZooKeeper
Java框架</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 分布式可重入排它锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>InterProcessLock</span><span class=w> </span><span class=n>lock1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InterProcessMutex</span><span class=p>(</span><span class=n>client</span><span class=p>,</span><span class=w> </span><span class=n>lockPath1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 分布式不可重入排它锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>InterProcessLock</span><span class=w> </span><span class=n>lock2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InterProcessSemaphoreMutex</span><span class=p>(</span><span class=n>client</span><span class=p>,</span><span class=w> </span><span class=n>lockPath2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 将多个锁作为一个整体</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>InterProcessMultiLock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InterProcessMultiLock</span><span class=p>(</span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=n>lock1</span><span class=p>,</span><span class=w> </span><span class=n>lock2</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>获取锁</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>lock</span><span class=p>.</span><span class=na>acquire</span><span class=p>(</span><span class=n>10</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>释放锁</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>lock</span><span class=p>.</span><span class=na>release</span><span class=p>()</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>Etcd</p></li></ul></li></ul></li><li><p>分布式事务</p><ul><li>CAP基础理论和BASE理论</li><li>一致性<ul><li>强一致性：写什么读到的就是什么</li><li>弱一致性：不一定能读到最新值，只能在某个时刻能达到数据一致</li><li>最终一致性：保证一定时间内达到数据一致</li></ul></li><li>柔性事务：追求最终一致，是BASE理论+业务实践，如TCC、Saga、MQ事务、本地消息表<ul><li>TCC（补偿事务）<ul><li>Try 尝试阶段：尝试执行。完成业务检查，并预留好必须的业务资源</li><li>Confirm 确认阶段：确认执行。当所有参与者Try阶段执行成功时，就会执行Confirm，并处理预留的业务资源</li><li>Cancel 取消阶段：取消执行，释放Try预留的业务资源</li><li>常见框架：ByteTCC、Seata、Hmily</li></ul></li><li>Saga<ul><li>长事务解决方案，将长事务拆分成多个本地短事务，每个短事务都会有个补偿动作，执行失败会恢复</li></ul></li><li>MQ事务<ul><li>RocketMQ：两阶段提交，超过最大重试次数，放入死信队列，手动处理，如果消息队列挂掉，数据库事务无法执行</li><li>QMQ：本地消息表，将分布式事务拆分成本地事务，即使消息队列挂掉也不影响数据库执行</li></ul></li></ul></li><li>刚性事务：追求强一致，如2PC、3PC<ul><li>2PC（两阶段提交）<ul><li>准备阶段：事务管理者向参与者询问本地事务操作是否执行成功，根据结果并不执行提交事务，而是进行提交阶段</li><li>提交阶段：事务管理者向参与者询问提交事务操作是否执行成功，根据结果来执行提交或回滚操作，完成后会结束当前分布式事务</li><li>存在问题<ul><li>同步阻塞：事务阶段会一直占用相关资源，导致阻塞</li><li>数据不一致：网络问题导致部分参与者收不到comitt/rollback情况时，会导致数据不一致</li><li>单点问题：管理者挂掉会导致参与者一直卡在提交阶段</li></ul></li></ul></li><li>3PC（三阶段提交）<ul><li>询问阶段：询问参与者能否执行本地数据库操作</li><li>准备阶段：当所有参与者都可执行时，才会执行本地事务操作，然后继续2PC阶段的步骤</li><li>提交阶段：同2PC阶段步骤</li><li>引入超时机制避免出现一直阻塞</li></ul></li></ul></li></ul></li><li><p>分布式配置中心</p><ul><li>Spring Cloud Config</li><li>Nacos</li><li>Apollo</li></ul></li><li><p>RPC</p><ul><li>角色<ul><li>客户端（服务消费端）：调用远程方法的一端</li><li>客户端Stub（桩）：代理类，将调用的类、方法、方法参数等传递到服务端</li><li>网络传输：将调用的信息传递到服务端，然后将服务器执行的结果返回给客户端</li><li>服务端Stub（桩）：服务端实际收到请求后，执行对应的方法并返回结果给客户端</li><li>服务端（服务提供端·）：提供远程方法的一端</li></ul></li><li>原理<ol><li>客户端（Client）以本地方式调用远程服务</li><li>客户端Stub收到调用后，将类、方法、方法参数组装成能进行网络传输的消息体（序列化）：RpcRequest</li><li>客户端Stub找到远程调用的地址，并将消息以序列化方式发送到服务提供端</li><li>服务端Stub收到消息将消息反序列化为Java对象：RpcRequest</li><li>服务端Stub根据RpcRequest的类、方法、方法参数调用本地方法</li><li>服务端Stub得到方法执行结果并将其组装成进行网络传输的消息体（序列化）：RpcResponse</li><li>客户端Stub接收到消息，并将其反序列化成为Java对象，得到最终结果</li></ol></li><li>解决方案<ul><li>Dubbo</li><li>Motan</li><li>gRPC</li><li>Thrift</li></ul></li></ul></li></ol><h2 id=nacos--elasticsearch--kafka>Nacos | ElasticSearch | Kafka</h2><h3 id=nacos>Nacos</h3><h3 id=elasticsearch>ElasticSearch</h3><h3 id=kafka>Kafka</h3><ul><li>消息模型：发布-订阅模型<ul><li>使用主题（Topic）作为消息通信载体，通过主题传递给所有订阅zhe</li></ul></li><li></li><li></li></ul><h2 id=你还有什么要问我的吗>你还有什么要问我的吗</h2><ol><li>同级：能不能谈谈你作为⼀个公司⽼员⼯对公司的感受？</li><li>领导：<ul><li>部⻔的主要⼈员分配以及对应的主要⼯作能简单介绍⼀下吗？</li><li>未来如果我要加⼊这个团队，你对我的期望是什么？</li></ul></li><li>boss: 贵公司的发展⽬标和⽅向是什么?</li></ol><blockquote><p>GC 日志</p><p>2024-03-23T10:15:23.123-0800:
1.234: [GC (Allocation Failure) [PSYoungGen: 65536K->16384K(76288K)] 65536K->32768K(251392K), 0.0157545 secs] [Times: user=0.02 sys=0.01, real=0.02 secs]
2024-03-23T10:15:25.456-0800:
3.456: [GC (Allocation Failure) [PSYoungGen: 81920K->20480K(76288K)] 98304K->57344K(251392K), 0.0196028 secs] [Times: user=0.02 sys=0.01, real=0.02 secs]
2024-03-23T10:15:27.789-0800:
5.789: [Full GC (Ergonomics) [PSYoungGen: 20480K->0K(76288K)] [ParOldGen: 36864K->49152K(175104K)] 57344K->49152K(251392K), [Metaspace: 20480K->20480K(1067008K)], 0.1056299 secs] [Times: user=0.11 sys=0.01, real=0.11 secs]
2024-03-23T10:15:30.123-0800:
8.123: [GC (Allocation Failure) [PSYoungGen: 65536K->16384K(76288K)] 114688K->81920K(251392K), 0.0257884 secs] [Times: user=0.03 sys=0.01, real=0.03 secs]
2024-03-23T10:15:32.456-0800:
10.456: [GC (Allocation Failure) [PSYoungGen: 81920K->20480K(76288K)] 139264K->106496K(251392K), 0.0212413 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
2024-03-23T10:15:34.789-0800:
12.789: [Full GC (Ergonomics) [PSYoungGen: 20480K->0K(76288K)] [ParOldGen: 86016K->90112K(200704K)] 106496K->90112K(251392K), [Metaspace: 20480K->20480K(1067008K)], 0.1468552 secs] [Times: user=0.14 sys=0.01, real=0.15 secs]</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/%E9%9D%A2%E8%AF%95/>面试</a></section></footer></article><script src=//unpkg.com/@waline/client@v2/dist/waline.js></script><link href=//unpkg.com/@waline/client@v2/dist/waline.css rel=stylesheet><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({avatar:"",dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo","https://cdn.jsdelivr.net/gh/walinejs/emojis/qq","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://cdn.jsdelivr.net/npm/sticker-heo@2022.7.5/Sticker-100/"],lang:"",locale:{admin:"👻狗管理",placeholder:"🎉留下你的脚印."},placeholder:"",requiredMeta:["name","email","url"],serverURL:"https://waline-test-two-umber.vercel.app/",visitor:""})</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2024 天才熊猫君</section><section class=powerby><a href=https://beian.miit.gov.cn/ target=_blank>鄂ICP备2021016891号</a><br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.21.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>