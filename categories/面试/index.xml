<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>面试 on 天才熊猫君</title><link>https://blog.icharles.work/categories/%E9%9D%A2%E8%AF%95/</link><description>Recent content in 面试 on 天才熊猫君</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 10 Apr 2024 13:36:34 +0800</lastBuildDate><atom:link href="https://blog.icharles.work/categories/%E9%9D%A2%E8%AF%95/index.xml" rel="self" type="application/rss+xml"/><item><title>面试知识点</title><link>https://blog.icharles.work/p/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</link><pubDate>Wed, 10 Apr 2024 13:36:34 +0800</pubDate><guid>https://blog.icharles.work/p/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</guid><description>&lt;h2 id="开场白">开场白&lt;/h2>
&lt;p>您好,我叫XX.统招本科毕业于XX,有6年开发经验,2年管理经验,从0到1构建多个项目,可带3-5人小团队.具有独立完成复杂工作,指导初中级开发的能力.同时熟悉系统设计、性能优化、敏捷开发.
在上⼀个公司我参与了中国山东网项目开发,主要职责是对开源框架进行微服务改造,核心业务模块拆分以及负责开发一些与平台运营相关的系统.&lt;/p>
&lt;h2 id="集合">集合&lt;/h2>
&lt;ol>
&lt;li>List | ArrayList | LinkedList | CopyOnWriteArrayList&lt;/li>
&lt;li>Set | HashSet | LinkedHashSet | TreeSet&lt;/li>
&lt;li>Queue | PriorityQueue | BlockingQueue | DelayQueue&lt;/li>
&lt;li>Map | HashMap | LinkedHashMap | ConcurrentHashMap&lt;/li>
&lt;/ol>
&lt;h2 id="多线程">多线程&lt;/h2>
&lt;ol>
&lt;li>线程的生命周期和状态&lt;/li>
&lt;li>死锁 | 避免死锁&lt;/li>
&lt;li>Java 内存模型&lt;/li>
&lt;li>volatile&lt;/li>
&lt;li>乐观锁与悲观锁&lt;/li>
&lt;li>synchronized&lt;/li>
&lt;li>ReentrantLock | Condition&lt;/li>
&lt;li>ReentrantReadWriteLock | StampedLock&lt;/li>
&lt;li>ThreadLocal&lt;/li>
&lt;li>线程池 | ThreadPoolExcutor | 参数&lt;/li>
&lt;li>常见并发容器&lt;/li>
&lt;li>AQS | 常见同步工具类
&lt;ul>
&lt;li>Semaphore (permits accquire(permits&amp;ndash;) release(permits++) ) 使用场景：控制并发访问量和单机限流&lt;/li>
&lt;li>CountDownLatch (count countdown(count&amp;ndash;) await(count==0)) 使用场景：并行任务和同步操作&lt;/li>
&lt;li>CyclicBarrier (parties await)
使用场景：主要应用场景和 &lt;code>CountDownLatch&lt;/code> 类似&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Atomic | CAS算法 Unsafe.compareAndSwap native&lt;/li>
&lt;li>CompletableFuture&lt;/li>
&lt;/ol>
&lt;h2 id="jvm">JVM&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>内存区域&lt;/p>
&lt;ul>
&lt;li>堆 + 字符串常量池 (对象实例 + 字符串)&lt;/li>
&lt;li>程序计数器 (1. 字节码解释器改变程序计数器来依次读取指令,实现流程控制 2. 记录线程执行的位置)&lt;/li>
&lt;li>栈 (栈帧&amp;ndash;&amp;gt; 局部变量表 + 操作数栈(中间计算结果) + 动态链接(调用其他方法时,将符号引用转化为直接引用) +
方法返回地址)&lt;/li>
&lt;li>本地方法栈 (native方法 同栈帧)&lt;/li>
&lt;li>方法区(元空间(类信息 + 字段信息 + 方法信息 + 静态变量 + 常量 + JIT编译后的代码缓存) + 运行时常量池(类符号引用 +
字段符号引用 + 方法符号引用 + 接口方法符号))&lt;/li>
&lt;li>本地内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>类创建过程&lt;/p>
&lt;ol>
&lt;li>
&lt;p>加载(类加载器加载)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>连接&lt;/p>
&lt;ul>
&lt;li>
&lt;p>验证(验证 class文件格式检查 字节码语义检查 程序语义检查 类正确性检查)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>准备(分配内存 初始化零值 设置对象头(类的元数据 哈希码 GC分代年龄 是否启用偏向锁))&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解析(将运行时常量池符号引用替换为直接引用,得到类、字段、方法在内存中的指针或偏移量)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>初始化(clinit() 调用构造方法)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>卸载(类的class对象被GC)&lt;/p>
&lt;ul>
&lt;li>实例对象被GC&lt;/li>
&lt;li>没有被引用&lt;/li>
&lt;li>类加载器被GC (BootstrapClassLoader,ExtClassLoader,AppClassLoader 不会被GC)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>死亡对象判断算法 (引用计数 + 可达性分析)&lt;/p>
&lt;ul>
&lt;li>
&lt;p>GC ROOTS对象：&lt;/p>
&lt;ul>
&lt;li>成员对象&lt;/li>
&lt;li>静态对象&lt;/li>
&lt;li>常量对象&lt;/li>
&lt;li>实例对象&lt;/li>
&lt;li>同步锁持有对象&lt;/li>
&lt;li>native对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>引用类型&lt;/p>
&lt;ul>
&lt;li>
&lt;p>强引用 不会被GC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>弱应用 被发现就会被GC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>软引用 内存不足,就会被GC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虚引用 随时会被GC&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>垃圾收集算法&lt;/p>
&lt;ul>
&lt;li>标记 - 清除 (先标记存活对象,标记完成后后清除剩余对象)&lt;/li>
&lt;li>复制 (腾出一半空间,将可用对象复制到这片空间,然后清除另一半的空间)&lt;/li>
&lt;li>标记 - 整理 (标记存活对象,然后向一端移动,清理端边界以外的对象)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>垃圾收集器 (Serial + Serial Old | Paraller New (Paraller Scavenge + Paraller Old) | CMS (初始标记 -&amp;gt; 并发标记 - &amp;gt; 重新标记 -&amp;gt; 并发清除)| G1 | ZGC)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类加载过程&lt;/p>
&lt;ul>
&lt;li>加载 根据全类名找到二进制数据，转换成方法区结构，生成一个Class对象作为方法区入口&lt;/li>
&lt;li>验证 class文件格式检查 字节码语言检查 程序语义检查 类正确性检查&lt;/li>
&lt;li>准备 分配内存 初始化零值 设置对象头&lt;/li>
&lt;li>解析 常量池中符号引用转化成直接引用，获取类和字段在内存中的偏移量&lt;/li>
&lt;li>初始化 执行clinit方法&lt;/li>
&lt;li>使用&lt;/li>
&lt;li>卸载 被GC回收/该类的所有实例对象被GC/该类的类加载器的实例被GC/该类没有被任何地方引用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>类加载器 | 破坏双亲委派&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JVM参数 以及 线上排查问题思路&lt;/p>
&lt;ul>
&lt;li>
&lt;p>GC日志记录&lt;/p>
&lt;ul>
&lt;li>&lt;code>-XX:+PrintGCDetails&lt;/code>：打印基本 GC 信息&lt;/li>
&lt;li>&lt;code>-XX:+PrintGCDateStamps&lt;/code>：打印 GC 日期信息&lt;/li>
&lt;li>&lt;code>-XX:+PrintTernuringDistribution&lt;/code>：打印对象分布&lt;/li>
&lt;li>&lt;code>-XX:+PrintHeapAtGC&lt;/code>：打印堆数据&lt;/li>
&lt;li>&lt;code>-XX:+PrintReferenceGC&lt;/code>：打印Reference处理信息&lt;/li>
&lt;li>&lt;code>-XX:+PrintGCApplicationStoppedTime&lt;/code>：打印Stop The World的时间&lt;/li>
&lt;li>&lt;code>-XX:+PrintSafepointStatistics&lt;/code>：打印safepoint信息&lt;/li>
&lt;li>&lt;code>-XX:PrintSafepointStatisticsCount=1&lt;/code>：1个safepoint&lt;/li>
&lt;li>&lt;code>-Xloggc:/path/to/gc-%t.log&lt;/code>：GC日志输出文件的文件路径&lt;/li>
&lt;li>&lt;code>-XX:+UseGCLogFileRotation&lt;/code>：开启日志文件分割&lt;/li>
&lt;li>&lt;code>-XX:NumberOfGCLogFiles=14&lt;/code>：最多分割几个文件，超过之后就从头开始写&lt;/li>
&lt;li>&lt;code>-XX:GCLogFileSize=50M&lt;/code>：每个文件大小上限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>处理OOM&lt;/p>
&lt;ul>
&lt;li>&lt;code>-XX:+HeapDumpOnOutOfMemoryError&lt;/code> ：遇到OOM时将heap转储到物理文件中&lt;/li>
&lt;li>&lt;code>-XX:HeapDumpPath=./java_pid&amp;lt;pid&amp;gt;.hprof&lt;/code>：写入文件的路径&lt;/li>
&lt;li>&lt;code>-XX:OnOutOfMemoryError=&amp;quot;&amp;lt; cmd args &amp;gt;;&amp;lt; cmd args &amp;gt;&amp;quot;&lt;/code>：当内存不足时会执行命令&lt;/li>
&lt;li>&lt;code>-XX:+UseGCOverheadLimit&lt;/code>：限制GC花费的VM时间比例&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>线上示例&lt;/p>
&lt;ul>
&lt;li>
&lt;p>设置应用的元空间大小、堆内存大小、新生代大小、栈大小、Eden区和Survivor区比例&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ENV&lt;/span> &lt;span class="nv">JAVA_OPTS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms512m -Xmx512m -Xmn128m -Xss256k -XX:SurvivorRatio=8&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>以服务器模式启动、禁止系统调用System.gc()、使用ParNewGC为新生代垃圾回收器、CMS为老年代垃圾回收器、老年代使用的空间达到
70% 时就开始垃圾回收、 CMS 垃圾回收时卸载不再需要的类、并行处理软引用、弱引用和虚引用、在 CMS 的 remark 阶段之前进行一次
young generation 垃圾回收、出现内存溢出错误时导出堆信息、打印垃圾回收的详细信息，包括每次垃圾回收的详细情况、时间戳、堆的情况、应用暂停的时间等&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ENV&lt;/span> &lt;span class="nv">JAVA_FIXED_ARGS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;-server -XX:+DisableExplicitGC -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSInitiatingOccupancyOnly\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> -XX:CMSInitiatingOccupancyFraction=70 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses -XX:+CMSClassUnloadingEnabled\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> -XX:+ParallelRefProcEnabled -XX:+CMSScavengeBeforeRemark -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>设置JVM错误文件的路径地址(%p = pid)、发生OOM转储文件的路径、垃圾回收日志的路径(%t=timestamp)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ENV&lt;/span> &lt;span class="nv">JAVA_GC_LOG_PATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;-XX:ErrorFile=/var/applog/gc/starfish-info-backend/hs_err_pid%p.log -XX:HeapDumpPath=/var/applog/gc/starfish-info-backend\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> -Xloggc:/var/applog/gc/starfish-info-backend/gc%t.log&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>设置环境变量为生产环境&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ENV&lt;/span> &lt;span class="nv">PARAMS&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;--spring.profiles.active=prod&amp;#34;&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>Dockerfile启动java进程的命令&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">ENTRYPOINT&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;sh&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;-c&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;java -Dloader.path=/app/libs/ -Djava.security.egd=file:/dev/./urandom -Dfile.encoding=UTF-8\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s2"> &lt;/span>&lt;span class="nv">$JAVA_OPTS&lt;/span>&lt;span class="s2"> &lt;/span>&lt;span class="nv">$JAVA_FIXED_ARGS&lt;/span>&lt;span class="s2"> &lt;/span>&lt;span class="nv">$JAVA_GC_LOG_PATH&lt;/span>&lt;span class="s2"> -jar /app/app.jar &lt;/span>&lt;span class="nv">$PARAMS&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>堆结构:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>新生代&lt;/th>
&lt;th>老年代&lt;/th>
&lt;th>元空间&lt;/th>
&lt;th>本地内存&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Eden | S0 |S1&lt;/td>
&lt;td>Ternured&lt;/td>
&lt;td>MetaSpace(初始20.8m)&lt;/td>
&lt;td>代码缓存 + Thread (线程私有)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-XX:NewSize=2048M&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-XX:MaxNewSize=3096M&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-Xmn2048m&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-XX:NewRatio=1 (老年代:新生代 = 1:1)&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-Xms8G&lt;/td>
&lt;td>-Xms8G&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-Xmx8G&lt;/td>
&lt;td>-Xmx8G&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>-XX:MetaspaceSize=512m&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>-XX:MaxMetaspaceSize=512m&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>-Xss256k（栈大小）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="spring-spring-mvc-springboot">Spring Spring MVC SpringBoot&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Spring IOC &amp;amp; Spring AOP&lt;/p>
&lt;ul>
&lt;li>IOC: 将创建对象的控制权交给Spring容器&lt;/li>
&lt;li>AOP: 在程序执行过程中动态织入代码,实现对横切关注点的模块化管理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Spring 核心流程图 （创建Bean过程）&lt;/p>
&lt;ol>
&lt;li>根据注解或配置文件获取Bean的定义&lt;/li>
&lt;li>通过反射创建Bean的实例&lt;/li>
&lt;li>通过set方法设置属性&lt;/li>
&lt;li>如果实现了BeanNameAware|BeanClassLoaderAware|BeanFactoryAware接口，则调用对应的set方法&lt;/li>
&lt;li>如果实现了BeanPostProcessor接口，则调用postProcessorBeforeInitialization()方法&lt;/li>
&lt;li>如果实现了InitializingBean接口,则调用afterPropertiesSet方法&lt;/li>
&lt;li>如果指定了init-method方法，则执行指定方法&lt;/li>
&lt;li>如果实现了BeanPostProcessor接口，则调用postProcessorAfterInitialization()方法&lt;/li>
&lt;li>使用Bean&lt;/li>
&lt;li>如果实现了DisposableBean接口，则调用destory()方法&lt;/li>
&lt;li>如果指定了destory-method方法，则执行指定方法&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>Spring AOP通知方式&lt;/p>
&lt;ul>
&lt;li>前置通知&lt;/li>
&lt;li>后置通知&lt;/li>
&lt;li>返回通知&lt;/li>
&lt;li>异常通知&lt;/li>
&lt;li>环绕通知&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Spring 管理事务方式| 隔离级别 | 传播行为&lt;/p>
&lt;ul>
&lt;li>事务管理方式：
&lt;ul>
&lt;li>编程式： TransacationManager手动提交&lt;/li>
&lt;li>声明式： xml|注解 (@Transactional) 自动提交&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>隔离级别：
&lt;ul>
&lt;li>采用数据库的隔离级别 (Default)&lt;/li>
&lt;li>读未提交 (Read Uncommited)&lt;/li>
&lt;li>读已提交 (Read Commited)&lt;/li>
&lt;li>可重复读 (MySQL数据库的默认隔离级别 Repetable Read)&lt;/li>
&lt;li>串行化 (Serializable)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>传播行为：
&lt;ul>
&lt;li>Requried：必须要有一个事务,没有就创建&lt;/li>
&lt;li>Requried_New：必要需要有一个事务,有也创建&lt;/li>
&lt;li>Support: 可以有一个事务,没有就以非事务运行&lt;/li>
&lt;li>Not_Support: 有没有都以非事务运行&lt;/li>
&lt;li>Mandatory: 必须要有一个事务,没有就抛异常&lt;/li>
&lt;li>Never: 绝对不能有事务,有就抛异常&lt;/li>
&lt;li>Nested: 有就嵌套事务,没有就创建&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Spring MVC 流程&lt;/p>
&lt;ol>
&lt;li>客户端请求,DispatcherServlet拦截请求&lt;/li>
&lt;li>DispatcherServlet调用HandlerMapping,HandlerMapping根据请求路径找到对应的Handler&lt;/li>
&lt;li>DispatcherServlet调用HandlerAdapter执行Handler&lt;/li>
&lt;li>Handler处理完请求后,返回ModelAndView给DispatcherServlet,Model是返回的数据对象,View是逻辑视图&lt;/li>
&lt;li>DispatcherServlet调用ViewResolver对逻辑视图进行解析,找到真正的视图&lt;/li>
&lt;li>DispatcherServlet把返回的Model传给视图进行渲染&lt;/li>
&lt;li>把渲染后的视图返回响应&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>SpringBoot 常用注解 自动装配原理&lt;/p>
&lt;p>常用注解： @SpringBootApplication (@ComponetScan @Configuration @EnableAutoConfiguration = @Import(
AutoConfigurationImportSelector))&lt;/p>
&lt;p>自动装配原理:
SpringBoot通过@EnableAutoConfiguration注解实现了自动装配,@EnableAutoConfiguration通过AutoConfigurationImportSelector的getAutoConfigurationEntry方法,使用SpringFactoryLoader加载META-INF/Spring.factories文件,获取EnableAutoConfiguration指定的类,并过滤掉不满足Condition的类,实现自动装配.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>什么是SpringBootStarter 自定义Starter&lt;/p>
&lt;ul>
&lt;li>starter是为SpringBoot提供一套快速的默认配置的机制，使用SpringFactoryLoader实现.&lt;/li>
&lt;li>实现自定义starter需要: 1.导入Spring依赖 2.自定义配置类 3.编写META-INF/spring.factories，指定enableAutoConfiguration要加载的类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>spring循环依赖怎么解决（说出三级缓存源码细节）&lt;/p>
&lt;ol>
&lt;li>SingletonObjects 一级缓存 存放成品Bean&lt;/li>
&lt;li>EarlySingletonObjects 二级缓存 存放过渡Bean包括原始Bean和代理Bean&lt;/li>
&lt;li>SingletonFactories 三级缓存 存放ObjectsFactory对象,实际使用getEarlyBeanReference()方法获取原始Bean或代理Bean&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>如果是只有两级缓存,代理Bean每次生成的对象会不一样,不满足Spring单例原则.&lt;/p>
&lt;p>2.6.X版本默认关闭循环依赖,如需开启在配置文件中指定spring.main.allow-circular-references=true&lt;/p>
&lt;p>前置条件:对象是单例的且开启了循环依赖,默认会将未初始化完成的Bean放入三级缓存中,循环依赖的对象会从三级缓存中找到依赖的对象,并在三级缓存销毁,放入二级缓存中.等初始化完成就从二级缓存中销毁,放入一级缓存中.&lt;/p>
&lt;/blockquote>
&lt;h2 id="mysql">MySQL&lt;/h2>
&lt;ol>
&lt;li>MySQL基础架构
&lt;ul>
&lt;li>连接器&lt;/li>
&lt;li>查询缓存&lt;/li>
&lt;li>分析器&lt;/li>
&lt;li>优化器&lt;/li>
&lt;li>执行器&lt;/li>
&lt;li>存储引擎&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MySQL存储引擎
&lt;ul>
&lt;li>MyISAM | InooDB 区别如下
&lt;ul>
&lt;li>MyISAM不支持事务，InooDB支持事务&lt;/li>
&lt;li>MyISAM和InooDBd都使用B+树作为数据结构，但实现方式不一样&lt;/li>
&lt;li>MyISAM只有表锁，InooDB有行锁，表锁，读锁，写锁，MVCC等&lt;/li>
&lt;li>MyISAM只有非聚簇索引，InooDB既有聚簇索引也有非聚簇索引&lt;/li>
&lt;li>MyISAM不支持外键，InooDB支持外键&lt;/li>
&lt;li>MyISAM不支持崩溃恢复，InooDB可以依赖redo log恢复数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MySQL索引
&lt;ul>
&lt;li>聚簇索引 | 非聚簇索引&lt;/li>
&lt;li>主键索引 | 普通索引,唯一索引,外键索引,联合索引,全文索引&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;ul>
&lt;li>最左前缀匹配原则： 使用联合索引时，有最左匹配原则，即从左往右，依次匹配&lt;/li>
&lt;li>索引下推： 即将查询条件进行优化，直接过滤掉不满足条件的记录&lt;/li>
&lt;li>为什么选择B+树作为索引的数据结构，有什么优点: IO查询稳定,范围查询更快.&lt;/li>
&lt;li>一个高度为3的B+树最多能存多少条记录:&lt;/li>
&lt;/ul>
&lt;p>​ 记录数 = 根节点指针数 * 单个叶子节点记录数
​ = 16&lt;em>1024/(6(InnoDB指针大小)+4(int主键大小)/8(bigint主键大小)) * (16kb(页大小)/1kb(单条数据最大长度))
​ = 16&lt;/em>1024/10(14) (一层容量指针数) * 16*1024/10(14) (二层容量指针数) * 16
​ = 1170 * 1170 * 16
​ = 21,902,400&lt;/p>
&lt;ul>
&lt;li>如果走辅助索引,最多需要经过几次IO: 3层 找到主键 再3层 找到数据 = 6次&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ol start="4">
&lt;li>MySQL日志
&lt;ul>
&lt;li>undo log
&lt;ul>
&lt;li>存放所有事务进行修改前的原始数据&lt;/li>
&lt;li>用于保证事务的原子性,另外MVCC的实现依赖于:隐藏字段和Read View以及undo log.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>redo log
&lt;ul>
&lt;li>用于保证数据库的持久性,会先通过buffer pool去读或修改数据,然后记录到redo log上,等待刷盘.&lt;/li>
&lt;li>存在刷盘机制,0-提交事务不刷盘,等待后台线程刷盘 1-提交事务就刷盘 2-提交事务写入文件缓存,等待后台线程刷盘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>bin log
&lt;ul>
&lt;li>用于数据库备份,会记录所有涉及更新数据的逻辑操作.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>为了解决写入redo log和bin log可能会出现不一致的情况，Mysql使用两阶段提交方案解决这个问题.&lt;/p>
&lt;ol>
&lt;li>在尚未提交事务时,会先prepare记录redo log.&lt;/li>
&lt;li>在已提交事务时,会先写入bin log日志,然后在redo log日志进行commit,提交写入redo log.&lt;/li>
&lt;li>即使在提交事务时,写入bin log发生异常,也不会有影响,只会回滚事务.&lt;/li>
&lt;li>在写入redo log时发生异常,不会回滚事务,而是通过找到bin log来写入数据.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ol start="5">
&lt;li>
&lt;p>MySQL事务&lt;/p>
&lt;ul>
&lt;li>特性: C是目的，AID是手段
&lt;ul>
&lt;li>A 原则性&lt;/li>
&lt;li>C 一致性&lt;/li>
&lt;li>I 隔离性&lt;/li>
&lt;li>D 持久性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>并发问题:
&lt;ul>
&lt;li>丢失修改: 修改操作被覆盖了&lt;/li>
&lt;li>脏读: 读到了未提交的数据&lt;/li>
&lt;li>不可重复读：两次读结果不一样&lt;/li>
&lt;li>幻读： 两次读的结果变多了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解决方案：
&lt;ul>
&lt;li>锁
&lt;ul>
&lt;li>读锁（共享锁）&lt;/li>
&lt;li>写锁（排他锁）&lt;/li>
&lt;li>表锁&lt;/li>
&lt;li>行锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MVCC： 多版本并发控制，版本号唯一，使用隐藏字段、Read View、Undo log实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>事务隔离级别： 使用锁和MVCC共同实现
&lt;ul>
&lt;li>读未提交： 解决丢失修改&lt;/li>
&lt;li>读已提交： 解决了丢失修改，脏读&lt;/li>
&lt;li>可重复读： 解决了丢失修改，脏读，不可重复读&lt;/li>
&lt;li>串行化： 解决了丢失修改，脏读，不可重复读，幻读&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>MySQL锁&lt;/p>
&lt;ul>
&lt;li>
&lt;p>读锁（共享锁）： 锁兼容,读取时多个事务可同时获取. 一般不加锁，除非显式指定了 select &amp;hellip; lock in share mode / select &amp;hellip; for share&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写锁（排他锁）: 锁不兼容,修改时只能由一个事务获取. 一般不加锁，除非显式指定了 select &amp;hellip; for update&lt;/p>
&lt;/li>
&lt;li>
&lt;p>表锁： 针对非索引字段加锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>行锁： 针对索引字段加锁&lt;/p>
&lt;ul>
&lt;li>
&lt;p>记录锁： Record Lock,单行记录上锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>间隙锁： Gap Lock,多行记录上锁但不包括本身&lt;/p>
&lt;/li>
&lt;li>
&lt;p>临键锁： Next-Key Lock = Record Lock + Gap Lock,多行记录上锁包括本身&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>RR的事务隔离级别下，行锁默认使用临键锁，但操作主键索引或唯一键索引时，会降级成记录锁&lt;/p>
&lt;p>快照读： 即普通的select 语句，不加锁，读的是记录的历史版本.&lt;/p>
&lt;p>当前读： 即加了读写锁的select 语句，读的是记录的当前版本.&lt;/p>
&lt;/blockquote>
&lt;ol start="7">
&lt;li>MVCC实现
&lt;ul>
&lt;li>读： 读当前事务开始时间的版本数据
&lt;ul>
&lt;li>写： 创建一个新的版本，写入版本数据&lt;/li>
&lt;li>在RR隔离级别下，如果是当前读（一致性锁定读）的情况下(for update/ insert / update / delete)，通过加入临键锁，锁住当前记录和范围，防止其他事务插入数据，出现幻读&lt;/li>
&lt;li>但如果是快照读（一致性非锁定读），即使是RR隔离级别，也会出现幻读&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>实现方式： 隐藏字段 、 Read View 、 undo log&lt;/p>
&lt;ul>
&lt;li>
&lt;p>隐藏字段&lt;/p>
&lt;ul>
&lt;li>DB_TRX_ID : 最后一次插入或更新该行的事务id&lt;/li>
&lt;li>DB_ROW_ID: 没有设置主键且没有唯一非空索引时，使用它来充当聚簇索引&lt;/li>
&lt;li>DB_ROLL_PTR: 回滚指针,指向undo log&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Read View&lt;/p>
&lt;ul>
&lt;li>可见性判断,里面保存了&amp;quot;当前对本事务不可见的其他活跃性事务&amp;quot;
&lt;ul>
&lt;li>m_low_limit_id: 目前出现过的最大的事务的ID+1,即下一个被分配事物的ID,大于等于这个ID的数据版本均不可见&lt;/li>
&lt;li>m_up_limit_id: 活跃事务列表m_ids中最小的事务ID,如果m_ids为空,则等价于m_low_limit_id.小于这个ID的数据版本均可见&lt;/li>
&lt;li>m_ids: Read View 创建时其他未提交的活跃事务的ID列表.创建Read
View时,将当前未提交事务的ID记录下来,后续即使他们修改了记录行的值,对当前事务也是不可见的.m_ids不包括当前事务自己和已提交的事务.&lt;/li>
&lt;li>m_creator_trx_id: 创建该Read View的事务ID.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>undo log&lt;/p>
&lt;ul>
&lt;li>用于事务回滚，恢复到修改前的样子&lt;/li>
&lt;li>用于MVCC，读历史版本的数据，实现一致性非锁定读&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据可见性算法 ： &amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不可重复读问题:&lt;/p>
&lt;ul>
&lt;li>RC: 每次读都会有新的Read View记录,有不可重复读问题&lt;/li>
&lt;li>RR: 事务开始时,只有第一次读有Read View记录,所以没有不可重复读问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>幻读问题:&lt;/p>
&lt;ul>
&lt;li>RR: 加入临键锁,解决幻读问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol start="8">
&lt;li>
&lt;p>MySQL执行计划分析&lt;/p>
&lt;ul>
&lt;li>explain + SQL
&lt;ul>
&lt;li>id： 查询序号&lt;/li>
&lt;li>select_type： 查询类型，用于区分普通查询，联合查询，子查询等
&lt;ul>
&lt;li>SIMPLE： 简单查询，不含UNION或子查询&lt;/li>
&lt;li>PRIMARY： 如果存在子查询，外层的SELECT标记为PRIMARY&lt;/li>
&lt;li>SUBQUERY： 子查询中的第一个SELECT&lt;/li>
&lt;li>UNION： 联合查询&lt;/li>
&lt;li>DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED&lt;/li>
&lt;li>UNION RESULT： UNION的查询结果&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>table：查询表名&lt;/li>
&lt;li>partitions：匹配分区&lt;/li>
&lt;li>type（重要）：表的访问方法
&lt;ul>
&lt;li>system：表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例&lt;/li>
&lt;li>const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件&lt;/li>
&lt;li>eq_ref： 当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join
方式，常用于使用主键或唯一索引的所有字段作为连表条件&lt;/li>
&lt;li>ref： 使用普通索引作为查询条件，查询结果可能找到多个符合条件的行&lt;/li>
&lt;li>fulltext&lt;/li>
&lt;li>ref_or_null&lt;/li>
&lt;li>index_merge： 当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引&lt;/li>
&lt;li>unique_subquery&lt;/li>
&lt;li>index_subquery&lt;/li>
&lt;li>range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了&lt;/li>
&lt;li>index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快&lt;/li>
&lt;li>ALL：全表扫描&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>possible_keys：查询可能用到的索引，null则可能没用到索引&lt;/li>
&lt;li>key（重要）：实际用到的索引，null则没用到索引&lt;/li>
&lt;li>key_len：索引最大长度，key=null那key_len=null&lt;/li>
&lt;li>ref：当使用索引等值查询时，与索引作比较的列或常量&lt;/li>
&lt;li>rows：大致需要读取的行数，越小越好&lt;/li>
&lt;li>filtered：条件过滤后的留存记录百分比&lt;/li>
&lt;li>Extra（重要）：查询的额外信息
&lt;ul>
&lt;li>Using filesort: 排序时使用了外部索引进行排序，没用到内部索引进行排序&lt;/li>
&lt;li>Using temporary： 创建临时表来存储查询结果，常见于order by 或 group by&lt;/li>
&lt;li>Using index: 使用了覆盖索引，不用回表，查询效率非常高&lt;/li>
&lt;li>Using index condition： 查询优化器使用到了索引下推这个特性&lt;/li>
&lt;li>Using where： 使用where条件进行了过滤，一般在没用到索引时出现&lt;/li>
&lt;li>Using join buffer： 连表查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>MySQL优化&lt;/p>
&lt;ul>
&lt;li>
&lt;p>避免隐式转换，隐式转换(两边数据类型不一致)会导致索引失效&lt;/p>
&lt;/li>
&lt;li>
&lt;p>避免使用select * 而是使用 select 字段&lt;/p>
&lt;/li>
&lt;li>
&lt;p>避免过多join表，不超过5个&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择合适的字段类型&lt;/p>
&lt;/li>
&lt;li>
&lt;p>避免出现大事务，拆分成小事务分批提交&lt;/p>
&lt;/li>
&lt;li>
&lt;p>正确使用索引&lt;/p>
&lt;/li>
&lt;li>
&lt;p>深度分页使用范围查询、子查询、延迟关联优化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用连续自增主键，而不是使用uuid(uuid范围查询无法排序)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="redis">Redis&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Redis为什么快&lt;/p>
&lt;ul>
&lt;li>基于内存,访问快&lt;/li>
&lt;li>基于Reactor模型开发了一套事件处理模型，主要是单线程事件循环和IO多路复用&lt;/li>
&lt;li>内部使用了多种优化后的数据类型,效率高&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>常见的读写缓存策略&lt;/p>
&lt;ul>
&lt;li>旁路缓存模式（应用程序直接与「数据库、缓存」交互，并负责对缓存的维护）
&lt;ul>
&lt;li>读：先从缓存读，读不到由「应用程序」从数据库读取数据后返回，再把数据放入缓存&lt;/li>
&lt;li>写：写入数据库，删掉缓存（服务端写）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>读写穿透模式（应用程序与「缓存」交互，「缓存」与「数据库」交互,负责缓存的维护）
&lt;ul>
&lt;li>读：先从缓存读，读不到由「缓存」从数据库读，并将结果放入缓存,返回数据给应用&lt;/li>
&lt;li>写：写入缓存，缓存不存在则更新数据库，存在则更新缓存,由「缓存」自己写数据库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>异步缓存写入 (应用程序与「缓存」交互，「缓存」与「数据库」交互,负责缓存的维护)
&lt;ul>
&lt;li>读：先从缓存读，读不到从数据库读，再放入缓存后返回&lt;/li>
&lt;li>写：写入缓存，不更新db,改为异步批量更新db&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis应用场景&lt;/p>
&lt;ul>
&lt;li>分布式锁&lt;/li>
&lt;li>限流&lt;/li>
&lt;li>消息队列&lt;/li>
&lt;li>延时队列&lt;/li>
&lt;li>分布式session&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis线程模型&lt;/p>
&lt;ul>
&lt;li>读写单线程，异步删除、网络请求多线程&lt;/li>
&lt;li>基于Reactor模式开发了一套文件事件处理器，以单线程方式运行，以I/O多路复用来监听多个套接字
&lt;ul>
&lt;li>文件事件处理器
&lt;ul>
&lt;li>多个socket（客户端连接）&lt;/li>
&lt;li>I/O多路复用程序（支持多个连接）&lt;/li>
&lt;li>文件事件分派器（将socket关联到事件处理器）&lt;/li>
&lt;li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis数据结构以及应用场景&lt;/p>
&lt;ul>
&lt;li>
&lt;p>String&lt;/p>
&lt;ul>
&lt;li>
&lt;p>结构特点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SDS(Simple Dynamic String)实现，好处在于&lt;/p>
&lt;ul>
&lt;li>可以扩容，避免缓冲区异常&lt;/li>
&lt;li>获取字符串长度复杂度为O(1)&lt;/li>
&lt;li>减少内存分配次数&lt;/li>
&lt;li>二进制安全&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>使用场景&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存储token/session/userId，序列化后的对象等&lt;/p>
&lt;ul>
&lt;li>实现分布式锁(setnx key value)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>List&lt;/p>
&lt;ul>
&lt;li>结构特点
&lt;ul>
&lt;li>双向链表，支持反向查找和遍历&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用场景
&lt;ul>
&lt;li>最新文章、最新动态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Set&lt;/p>
&lt;ul>
&lt;li>结构特点
&lt;ul>
&lt;li>无序集合，类似Java中的HashSet&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用场景
&lt;ul>
&lt;li>网站UV统计，文章点赞/已读统计，关注&lt;/li>
&lt;li>抽奖系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Sorted Set(Zset)&lt;/p>
&lt;ul>
&lt;li>结构特点
&lt;ul>
&lt;li>类似TreeSet和HashMap的结合,但增加了个权重参数score,使得可以排序，还可以根据score范围查询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用场景
&lt;ul>
&lt;li>排行榜&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>BitMap&lt;/p>
&lt;ul>
&lt;li>结构特点
&lt;ul>
&lt;li>key是元素本身，value是0/1，是一个存储0/1的数组，每个value占一个bit位&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用场景
&lt;ul>
&lt;li>用户签到情况、活跃用户情况、是否点赞/关注&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>HyperLogLog（基数统计）&lt;/p>
&lt;ul>
&lt;li>结构特点
&lt;ul>
&lt;li>基数计数概率算法，并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用场景
&lt;ul>
&lt;li>热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Geospatial&lt;/p>
&lt;ul>
&lt;li>结构特点
&lt;ul>
&lt;li>存储地理位置信息，基于 Sorted Set 实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用场景
&lt;ul>
&lt;li>附近的人&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis持久化机制&lt;/p>
&lt;ul>
&lt;li>快照（snapshotting,RDB）
&lt;ul>
&lt;li>是Redis默认持久化方式，通过创建快照来获取数据在某个时间点的副本&lt;/li>
&lt;li>默认使用bgsave进行持久化，通过创建子线程执行，而save操作会阻塞主线程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>追加读（append-only file,AOF）
&lt;ul>
&lt;li>每条更改数据的命令会先放入缓冲区(server.aof_buf)，然后写入AOF文件，最后通过fsync策略来决定何时同步到硬盘.&lt;/li>
&lt;li>AOF工作流程
&lt;ul>
&lt;li>命令追加（append）: 写命令放入AOF缓冲区&lt;/li>
&lt;li>文件写入（write）：将AOF缓冲区的数据写入系统内核缓冲区&lt;/li>
&lt;li>文件同步（fsync）：AOF缓存区根据fsync策略向磁盘做同步操作，写入AOF文件&lt;/li>
&lt;li>文件重写（rewrite）：AOF文件越来越来，需要定期重写来压缩AOF文件&lt;/li>
&lt;li>重新加载（reload）: 通过加载AOF文件来恢复数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>fsync策略
&lt;ul>
&lt;li>appendfsync always:
主线程调用write执行完成后，后台线程（aof_fsync线程）立马调用fsync函数进行同步 (&lt;code>write + fsync&lt;/code>)&lt;/li>
&lt;li>appenfsync eversec:
主线程调用write执行完成后，后台线程（aof_fsync线程）每秒调用fsync函数进行同步(&lt;code>write + 1秒 + fsync&lt;/code>)&lt;/li>
&lt;li>appendfsync
no：主线程调用write执行完成后，由操作系统决定什么时候调用fsync函数进行同步（&lt;code>write 不 fsync ,操作系统决定,Linux一般是30秒&lt;/code>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>rewrite
&lt;ul>
&lt;li>通过读取当前数据库的状态，然后生成一个新的AOF文件来替换旧的AOF文件&lt;/li>
&lt;li>同时维护了一个AOF重写缓冲区,以记录创建过程中出现的写命令,等创建完成后,将写命令追加到新的AOF文件中&lt;/li>
&lt;li>通过&lt;code>BGREWRITEAOF&lt;/code>命令来触发重写操作,会创建一个子线程进行重写操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>混合（RDB+AOF）
&lt;ul>
&lt;li>使用&lt;code>aof-use-rdb-preamble&lt;/code>命令开启混合持久化,AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头,但会导致可读性较差.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如何选择持久化
&lt;ul>
&lt;li>数据安全性要求高,选择RDB+AOF同时开启或者混合模式&lt;/li>
&lt;li>数据安全性要求不高时,选择RDB&lt;/li>
&lt;li>不建议只开启AOF,不易备份或快速重启恢复&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis内存管理策略&lt;/p>
&lt;ul>
&lt;li>过期数据存储方式
&lt;ul>
&lt;li>通过字典(redisDb)来存储key的过期时间,由dict属性存储键值对,expires属性存储过期时间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>过期数据删除策略
&lt;ul>
&lt;li>惰性删除
&lt;ul>
&lt;li>用到key时检查,是否需要删除.但会导致堆积过多过期key&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>定期删除
&lt;ul>
&lt;li>隔一段时间抽取一批key检查,是否需要删除.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>内存淘汰机制
&lt;ul>
&lt;li>volatile-lru: 淘汰最近最少使用的数据 (已设置过期时间)&lt;/li>
&lt;li>volatile-ttl: 淘汰要过期的数据 (已设置过期时间)&lt;/li>
&lt;li>volatile-random: 随机淘汰数据 (已设置过期时间)&lt;/li>
&lt;li>allkeys-lru: 内存不足时,淘汰最近最少的数据 (全部)&lt;/li>
&lt;li>allkyes-random: 内存不足时,随机淘汰数据 (全部)&lt;/li>
&lt;li>no-eviction: 禁止写入数据&lt;/li>
&lt;li>volatile-lfu: 淘汰最不经常使用的数据 (已设置过期时间)&lt;/li>
&lt;li>allkeys-lfu: 淘汰最不经常使用的数据 (全部)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis生产问题&lt;/p>
&lt;ul>
&lt;li>缓存穿透
&lt;ul>
&lt;li>访问大量无效key,透过缓存,直接请求数据库&lt;/li>
&lt;li>解决方案
&lt;ul>
&lt;li>缓存无效key&lt;/li>
&lt;li>布隆过滤器&lt;/li>
&lt;li>接口限流,IP黑名单&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缓存击穿
&lt;ul>
&lt;li>缓存的热点数据过期或不存在,大量请求数据库&lt;/li>
&lt;li>解决方案
&lt;ul>
&lt;li>缓存key时间设置比较长&lt;/li>
&lt;li>提前预热热点数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缓存雪崩
&lt;ul>
&lt;li>同一时间,大量缓存数据失效,大量请求数据库&lt;/li>
&lt;li>解决方案
&lt;ul>
&lt;li>多级缓存&lt;/li>
&lt;li>限流&lt;/li>
&lt;li>缓存预热&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缓存数据库一致性
&lt;ul>
&lt;li>旁路缓存模式: 先更新数据库,再删缓存.&lt;/li>
&lt;li>增加缓存更新重试机制: 隔断时间重试删除缓存,或者引入消息队列来删缓存(删除缓存消息写入mq,mq来重试删除.)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis集群&lt;/p>
&lt;ul>
&lt;li>Redis 多集群：主从模式,一主多从 （端口：6379）
&lt;ul>
&lt;li>优点: 简单&lt;/li>
&lt;li>缺点: 需要手动维护主节点信息,发生故障需要手动恢复&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis Sentinel：哨兵模式,一主多从,三哨兵 （端口：26379）
&lt;ul>
&lt;li>优点: 在主从模式的基础上,增加哨兵节点,以维护Redis节点状态,自动故障转移&lt;/li>
&lt;li>缺点: 不好动态扩容&lt;/li>
&lt;li>常见问题
&lt;ul>
&lt;li>有什么作用
&lt;ul>
&lt;li>监控：监控所有Redis节点状态&lt;/li>
&lt;li>故障转移：如果master出现异常，Sentinel会实现故障转移，将一台slave升级成master&lt;/li>
&lt;li>通知：通知新的master连接信息给slave，让它们执行replicaof成为新的master的slave&lt;/li>
&lt;li>配置提供：通知新的master连接信息给客户端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>检测节点是否下线
&lt;ul>
&lt;li>主观下线：某个Sentinel节点认为Redis节点下线（PING请求，PONG(LOADING/MASTERDOWN)超过响应时间）&lt;/li>
&lt;li>客观下线：超过半数Sentinel节点认为Redis节点下线&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如何选举新的master节点
&lt;ol>
&lt;li>slave在线: 节点必须在线&lt;/li>
&lt;li>slave优先级：通过slave-priority设置优先级，最高的成为master,没有优先级就看复制进度&lt;/li>
&lt;li>复制进度：数据最完整，复制进度最快的slave成为master&lt;/li>
&lt;li>runid: 如果优先级和复制进度一样，则runid最小的成为master&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Sentinel如何选举Leader
&lt;ul>
&lt;li>通过Raft算法选举出Leader&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Sentinel可以防止脑裂吗
&lt;ul>
&lt;li>发生网络隔离（也就是脑裂）时，master必须能写入slave，并能从节点得到响应。否则就拒绝接受新的写入命令&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis Cluster：切片集群,三主三从（端口：6379和16379）
&lt;ul>
&lt;li>优点: 官方推荐,提供主从复制、故障转移功能,很⽅便地进⾏横向拓展,动态扩容和缩容是其最⼤的优势&lt;/li>
&lt;li>缺点: 需要多服务器,适合数据量大,并发量⼤的场景&lt;/li>
&lt;li>常见问题
&lt;ul>
&lt;li>如何分片
&lt;ul>
&lt;li>Redis使用哈希槽分区,每个键值对属于一个哈希槽.&lt;code>哈希槽 = key ^ CRC-16 % 16384&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如何找到对应的哈希槽
&lt;ul>
&lt;li>根据Key通过上面的计算公式找到对应的哈希槽,然后再查询哈希槽和节点的映射关系&lt;/li>
&lt;li>如果是当前节点负责就返回响应结果&lt;/li>
&lt;li>如果不是则发送重定向错误,告诉客户端当前的哈希槽由哪个节点负责&lt;/li>
&lt;li>客户端则向目标节点发送请求并更新缓存的哈希槽分配信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为什么哈希槽是16384个(2^14)
&lt;ul>
&lt;li>哈希槽太大会导致心跳包变大,消耗带宽&lt;/li>
&lt;li>哈希槽总数越少,对存储的哈希槽信息的bitmap压缩效果好&lt;/li>
&lt;li>16384个槽节点占用空间2k(16384/8),空间小,并且不太会超过1000个主节点,完全够用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis Cluster 扩容缩容
&lt;ul>
&lt;li>扩容缩容的本质是重新分片,动态迁移哈希槽&lt;/li>
&lt;li>提供重定向机制(ASK|MOVED),在发生扩容缩容时,仍能对外提供服务&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis Cluster 节点通信
&lt;ul>
&lt;li>Cluster 各个节点使用Gossip协议通信,每个节点都维护了一份集群的状态信息&lt;/li>
&lt;li>Cluster 内置了Sentinel机制,通过Gossip协议相互探测健康状态,发生故障自动切换&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>一致性哈希：&lt;/p>
&lt;/blockquote>
&lt;h2 id="分布式">分布式&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>分布式共识算法&lt;/p>
&lt;ul>
&lt;li>CAP理论
&lt;ul>
&lt;li>C|Consistency: 一致性, 所有节点访问同一份最新的数据副本&lt;/li>
&lt;li>A|Availability: 可用性, 非故障节点在合理时间返回合理的响应&lt;/li>
&lt;li>P|Partition Tolerance: 分区容错性,当出现网络分区时,仍能对外提供服务&lt;/li>
&lt;li>一般时CP或AP架构,当发生网络分区时,P是一定需要保证的.选择CP还是AP就看业务场景&lt;/li>
&lt;li>但没有发生网络分区时,CA是能同时保证的.&lt;/li>
&lt;li>CP架构: ZooKeeper | AP架构: Eureka | CP&amp;amp;AP架构: Nacos&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>BASE理论
&lt;ul>
&lt;li>BA|Basically Available：基本可用, 允许损失部分可用性&lt;/li>
&lt;li>S|Soft-state：软状态, 允许系统存在中间状态,且不会影响系统整体可用性&lt;/li>
&lt;li>E|Eventually Consistent：最终一致性, 系统中的所有数据副本在经过一段时间同步后,最终会达到一致的状态.&lt;/li>
&lt;li>当发生网络分区时，要保证AP时，会放弃C，而BASE理论则是不保证强一致性，但要保证最终一致性.是对AP方案的补充.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Paxos算法
&lt;ul>
&lt;li>Basic Paxos：多节点就value达成共识
&lt;ul>
&lt;li>三种角色
&lt;ul>
&lt;li>提议者：接受客户端请求，发起提案（提案ID和提案value）&lt;/li>
&lt;li>接受者：对提案进行投票，同时记住投票历史&lt;/li>
&lt;li>学习者：超过半数投票的提案将会被执行运算，并发送给客户端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Multi Paxos：执行多个Basic Paxos&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Raft算法
&lt;ul>
&lt;li>拜占庭将军：在会出现故障或叛变节点时，需要保证系统的整体可用性&lt;/li>
&lt;li>共识算法：即使面对故障，服务器也可以在共享状态上达成一致&lt;/li>
&lt;li>基础
&lt;ul>
&lt;li>节点类型：某一时间，节点一定会是以下的身份类型
&lt;ul>
&lt;li>Leader：负责发起心跳，响应客户端，创建日志，同步日志&lt;/li>
&lt;li>Candidate：发起竞选（Follower竞争Leader产生的临时角色）&lt;/li>
&lt;li>Follower：接受Leader的心跳和日志同步数据，投票给Candidate&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>任期：每次选举的开始就是一次任期（term），如果没有选出Leader将会开启下个任期和选举&lt;/li>
&lt;li>日志：
&lt;ul>
&lt;li>log = entry&amp;lt;term,index,cmd&amp;gt;[] ;&lt;/li>
&lt;li>日志由entry数组构成，每一个事件成为一个entry，只有Leader可以创建entry；&lt;/li>
&lt;li>term = 任期；index = enry在log中下标；cmd = 应用到状态机的操作；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>领导人选举：
&lt;ul>
&lt;li>使用心跳机制来触发选举，超过半数投票的Candidate获得选举，成为Leader&lt;/li>
&lt;li>Follower会自增term号并转换状态为Candidate，并向其他节点发起RequestVoteRPC请求，直到有Leader出现或进行下一轮选举&lt;/li>
&lt;li>避免出现无限重复投票的情况，采用选举随机超时策略，增加一个选举随机超时时间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>日志复制：Leader 和 Follower 的日志需要保持一致，不一致时会删除Follower不一致的地方，将Leader记录的后续日志发给Follower&lt;/li>
&lt;li>安全性
&lt;ul>
&lt;li>选举限制&lt;/li>
&lt;li>节点崩溃&lt;/li>
&lt;li>时间与可用性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Gossip协议：分散式发散消息
&lt;ul>
&lt;li>集中式发散消息：一个节点向其他节点共享信息&lt;/li>
&lt;li>分散式发散消息：每个节点周期性随机向其他节点共享信息&lt;/li>
&lt;li>Redis Cluster 采用&lt;code>Gossip&lt;/code>协议来进行共享信息，每个节点都维护了一份Redis集群的状态信息&lt;/li>
&lt;li>消息传播模式
&lt;ul>
&lt;li>反熵：消除不同节点的数据差异，提高节点相似度，从而降低熵值（不确定性）&lt;/li>
&lt;li>传谣（谣言传播）：一个节点一旦有了新数据就成为了活跃节点，活跃节点周期性向其他节点发送新数据，直到所有节点都有了新数据&lt;/li>
&lt;li>差异：
&lt;ul>
&lt;li>反熵用于传播所有数据，传谣用于传播新数据&lt;/li>
&lt;li>反熵一般需要设计一个闭环，传谣适合节点数量更多和动态变化的场景&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>API网关：请求转发 + 请求过滤&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/distributed-system/api-gateway/up-35e102c633bbe8e0dea1e075ea3fee5dcfb.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Netflix Zuul&lt;/p>
&lt;ul>
&lt;li>Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Spring Cloud Gateway&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能,和 Zuul 2.x
的差别不大，也是通过过滤器来处理请求&lt;/p>
&lt;/li>
&lt;li>
&lt;p>工作流程&lt;/p>
&lt;ul>
&lt;li>路由判断(Predicate)：先经过Gateway Handler Mapping处理，经过Predicate判断符合哪个路由规则，再映射到后端服务&lt;/li>
&lt;li>请求过滤(Pre-Request)：然后请求到达Gateway Web Mapping处理，经过Filter Chain进行拦截和修改(
增加请求头、参数校验)，再转发请求到后端服务&lt;/li>
&lt;li>服务处理(Handler)：后端处理请求&lt;/li>
&lt;li>响应过滤(Post-Request)：后端处理请求完成后，返回给Gateway再次经过Filter Chain进行处理，再响应给客户端&lt;/li>
&lt;li>响应返回：过滤处理完成后，响应给客户端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Predicate&lt;/p>
&lt;ul>
&lt;li>断言配置：满足断言的条件后，就能映射到指定的服务&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png"
loading="lazy"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态路由：使用Nacos Server和Spring Cloud Alibaba Nacos Config实现动态路由，自动感知配置变化，动态配置网关信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Filter&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Pre：请求到服务前，对请求进行拦截和修改，如参数校验，权限校验，流量监控，日志输出，协议转换等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Post：请求处理完成后，对响应内容进行修改，如修改响应头、日志输出、流量监控&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>限流：Sentinel 模块实现限流，提供两种资源维度的限流：route 维度和自定义 API 维度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局异常处理：实现ErrorWebExceptionHandler的Handle方法&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>OpenResty&lt;/p>
&lt;ul>
&lt;li>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台,通过简单的 Lua 语言来扩展网关的功能，比如实现自定义的路由规则、过滤器、缓存策略等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Kong&lt;/p>
&lt;ul>
&lt;li>基于OpenResty（Nginx + Lua），由Kong Server、Apache Cassandra/PostgreSQL、Kong Dashboard组成，本身就是一个 Lua 应用程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>APISIX&lt;/p>
&lt;ul>
&lt;li>基于 OpenResty 和 etcd&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Shenyu&lt;/p>
&lt;ul>
&lt;li>基于 WebFlux&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>分布式ID&lt;/p>
&lt;ul>
&lt;li>基本要求
&lt;ul>
&lt;li>全局唯一：ID 全局唯一性&lt;/li>
&lt;li>高性能：生成速度要快&lt;/li>
&lt;li>高可用：生成服务要可用&lt;/li>
&lt;li>方便易用：拿来即用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解决方案
&lt;ul>
&lt;li>数据库主键自增（MySQL、Redis）：MySQL号段模式，Redis incr指令&lt;/li>
&lt;li>UUID、Snowflake（雪花算法）：生成速度快，ID有序，比较灵活但有可能出现时钟回拨导致重复ID问题&lt;/li>
&lt;li>UidGenerator：对雪花算法进行了改进，QPS更高，但18年后不再维护&lt;/li>
&lt;li>Leaf：支持号段模式和雪花算法，支持双号段，解决了时钟回拨问题，QPS 压测结果近 5w/s&lt;/li>
&lt;li>Tinyid：基于数据库号段模式，支持双号段，纯本地操作，无 HTTP 请求消耗&lt;/li>
&lt;li>IdGenerator：兼容所有雪花算法，解决了时钟回拨问题，不依赖外部存储系统，支持多语言调用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>分布式锁&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基本要求&lt;/p>
&lt;ul>
&lt;li>互斥：任意一个时刻，锁只能被一个线程持有&lt;/li>
&lt;li>高可用：当一个锁服务出现问题，能够自动切换到另外一个锁服务；即 锁一定会被释放&lt;/li>
&lt;li>可重入：节点可重复获取锁&lt;/li>
&lt;li>高性能：快速获取或释放锁&lt;/li>
&lt;li>非阻塞：拿不到锁不能无限等待&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>解决方案&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MySQL实现&lt;/p>
&lt;ul>
&lt;li>通过唯一索引或排它锁实现，但有性能差、不具备锁失效等机制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Redis&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>lua + setnx&lt;/code>指令获取简易锁&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># KEYS[1]-lockKey, ARGV[1]--requestId, ARGV[2]--expire&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> redis.call&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;setNx&amp;#39;&lt;/span>, KEYS&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>, ARGV&lt;span class="o">[&lt;/span>1&lt;span class="o">])&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="k">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> tonumber&lt;span class="o">(&lt;/span>ARGV&lt;span class="o">[&lt;/span>2&lt;span class="o">])&lt;/span> &amp;gt; &lt;span class="m">0&lt;/span> &lt;span class="k">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> redis.call&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;expire&amp;#39;&lt;/span>, KEYS&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>, ARGV&lt;span class="o">[&lt;/span>2&lt;span class="o">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> end
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> redis.call&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;get&amp;#39;&lt;/span>, KEYS&lt;span class="o">[&lt;/span>1&lt;span class="o">])&lt;/span> &lt;span class="o">==&lt;/span> ARGV&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="k">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> tonumber&lt;span class="o">(&lt;/span>ARGV&lt;span class="o">[&lt;/span>2&lt;span class="o">])&lt;/span> &amp;gt; &lt;span class="m">0&lt;/span> &lt;span class="k">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> redis.call&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;expire&amp;#39;&lt;/span>, KEYS&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span>, ARGV&lt;span class="o">[&lt;/span>2&lt;span class="o">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> end
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> end
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>lua + del&lt;/code>指令释放简易锁&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> redis.call&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;get&amp;#34;&lt;/span>,KEYS&lt;span class="o">[&lt;/span>1&lt;span class="o">])&lt;/span> &lt;span class="o">==&lt;/span> ARGV&lt;span class="o">[&lt;/span>1&lt;span class="o">]&lt;/span> &lt;span class="k">then&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> redis.call&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;del&amp;#34;&lt;/span>,KEYS&lt;span class="o">[&lt;/span>1&lt;span class="o">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>Redisson：锁的优雅续期&lt;/p>
&lt;ul>
&lt;li>使用&lt;code>Watch Dog&lt;/code>来监控和续期锁，执行未完成，每隔10秒就执行续期操作，将超时时间设置为30秒&lt;/li>
&lt;li>内置了可重入锁、自旋锁、公平锁、多重锁、红锁、读写锁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Zookeeper&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基于&lt;code>临时顺序节点&lt;/code>和&lt;code>Watcher（事件监听器)&lt;/code> 实现，推荐使用 Curator 来实现 ZooKeeper 分布式锁，是Netflix开源的ZooKeeper
Java框架&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 分布式可重入排它锁&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">InterProcessLock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lock1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterProcessMutex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lockPath1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 分布式不可重入排它锁&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">InterProcessLock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lock2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterProcessSemaphoreMutex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">client&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lockPath2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 将多个锁作为一个整体&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">InterProcessMultiLock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterProcessMultiLock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Arrays&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">asList&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lock2&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>获取锁&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">lock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">acquire&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TimeUnit&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>释放锁&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">lock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">release&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Etcd&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>分布式事务&lt;/p>
&lt;ul>
&lt;li>CAP基础理论和BASE理论&lt;/li>
&lt;li>一致性
&lt;ul>
&lt;li>强一致性：写什么读到的就是什么&lt;/li>
&lt;li>弱一致性：不一定能读到最新值，只能在某个时刻能达到数据一致&lt;/li>
&lt;li>最终一致性：保证一定时间内达到数据一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>柔性事务：追求最终一致，是BASE理论+业务实践，如TCC、Saga、MQ事务、本地消息表
&lt;ul>
&lt;li>TCC（补偿事务）
&lt;ul>
&lt;li>Try 尝试阶段：尝试执行。完成业务检查，并预留好必须的业务资源&lt;/li>
&lt;li>Confirm 确认阶段：确认执行。当所有参与者Try阶段执行成功时，就会执行Confirm，并处理预留的业务资源&lt;/li>
&lt;li>Cancel 取消阶段：取消执行，释放Try预留的业务资源&lt;/li>
&lt;li>常见框架：ByteTCC、Seata、Hmily&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Saga
&lt;ul>
&lt;li>长事务解决方案，将长事务拆分成多个本地短事务，每个短事务都会有个补偿动作，执行失败会恢复&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MQ事务
&lt;ul>
&lt;li>RocketMQ：两阶段提交，超过最大重试次数，放入死信队列，手动处理，如果消息队列挂掉，数据库事务无法执行&lt;/li>
&lt;li>QMQ：本地消息表，将分布式事务拆分成本地事务，即使消息队列挂掉也不影响数据库执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>刚性事务：追求强一致，如2PC、3PC
&lt;ul>
&lt;li>2PC（两阶段提交）
&lt;ul>
&lt;li>准备阶段：事务管理者向参与者询问本地事务操作是否执行成功，根据结果并不执行提交事务，而是进行提交阶段&lt;/li>
&lt;li>提交阶段：事务管理者向参与者询问提交事务操作是否执行成功，根据结果来执行提交或回滚操作，完成后会结束当前分布式事务&lt;/li>
&lt;li>存在问题
&lt;ul>
&lt;li>同步阻塞：事务阶段会一直占用相关资源，导致阻塞&lt;/li>
&lt;li>数据不一致：网络问题导致部分参与者收不到comitt/rollback情况时，会导致数据不一致&lt;/li>
&lt;li>单点问题：管理者挂掉会导致参与者一直卡在提交阶段&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>3PC（三阶段提交）
&lt;ul>
&lt;li>询问阶段：询问参与者能否执行本地数据库操作&lt;/li>
&lt;li>准备阶段：当所有参与者都可执行时，才会执行本地事务操作，然后继续2PC阶段的步骤&lt;/li>
&lt;li>提交阶段：同2PC阶段步骤&lt;/li>
&lt;li>引入超时机制避免出现一直阻塞&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>分布式配置中心&lt;/p>
&lt;ul>
&lt;li>Spring Cloud Config&lt;/li>
&lt;li>Nacos&lt;/li>
&lt;li>Apollo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>RPC&lt;/p>
&lt;ul>
&lt;li>角色
&lt;ul>
&lt;li>客户端（服务消费端）：调用远程方法的一端&lt;/li>
&lt;li>客户端Stub（桩）：代理类，将调用的类、方法、方法参数等传递到服务端&lt;/li>
&lt;li>网络传输：将调用的信息传递到服务端，然后将服务器执行的结果返回给客户端&lt;/li>
&lt;li>服务端Stub（桩）：服务端实际收到请求后，执行对应的方法并返回结果给客户端&lt;/li>
&lt;li>服务端（服务提供端·）：提供远程方法的一端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>原理
&lt;ol>
&lt;li>客户端（Client）以本地方式调用远程服务&lt;/li>
&lt;li>客户端Stub收到调用后，将类、方法、方法参数组装成能进行网络传输的消息体（序列化）：RpcRequest&lt;/li>
&lt;li>客户端Stub找到远程调用的地址，并将消息以序列化方式发送到服务提供端&lt;/li>
&lt;li>服务端Stub收到消息将消息反序列化为Java对象：RpcRequest&lt;/li>
&lt;li>服务端Stub根据RpcRequest的类、方法、方法参数调用本地方法&lt;/li>
&lt;li>服务端Stub得到方法执行结果并将其组装成进行网络传输的消息体（序列化）：RpcResponse&lt;/li>
&lt;li>客户端Stub接收到消息，并将其反序列化成为Java对象，得到最终结果&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>解决方案
&lt;ul>
&lt;li>Dubbo&lt;/li>
&lt;li>Motan&lt;/li>
&lt;li>gRPC&lt;/li>
&lt;li>Thrift&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="nacos--elasticsearch--kafka">Nacos | ElasticSearch | Kafka&lt;/h2>
&lt;h3 id="nacos">Nacos&lt;/h3>
&lt;h3 id="elasticsearch">ElasticSearch&lt;/h3>
&lt;h3 id="kafka">Kafka&lt;/h3>
&lt;ul>
&lt;li>消息模型：发布-订阅模型
&lt;ul>
&lt;li>使用主题（Topic）作为消息通信载体，通过主题传递给所有订阅zhe&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="你还有什么要问我的吗">你还有什么要问我的吗 &lt;/h2>
&lt;ol>
&lt;li>同级：能不能谈谈你作为⼀个公司⽼员⼯对公司的感受？&lt;/li>
&lt;li>领导：
&lt;ul>
&lt;li>部⻔的主要⼈员分配以及对应的主要⼯作能简单介绍⼀下吗？&lt;/li>
&lt;li>未来如果我要加⼊这个团队，你对我的期望是什么？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>boss: 贵公司的发展⽬标和⽅向是什么?&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>GC 日志&lt;/p>
&lt;p>2024-03-23T10:15:23.123-0800:
1.234: [GC (Allocation Failure) [PSYoungGen: 65536K-&amp;gt;16384K(76288K)] 65536K-&amp;gt;32768K(251392K), 0.0157545 secs] [Times: user=0.02 sys=0.01, real=0.02 secs]
2024-03-23T10:15:25.456-0800:
3.456: [GC (Allocation Failure) [PSYoungGen: 81920K-&amp;gt;20480K(76288K)] 98304K-&amp;gt;57344K(251392K), 0.0196028 secs] [Times: user=0.02 sys=0.01, real=0.02 secs]
2024-03-23T10:15:27.789-0800:
5.789: [Full GC (Ergonomics) [PSYoungGen: 20480K-&amp;gt;0K(76288K)] [ParOldGen: 36864K-&amp;gt;49152K(175104K)] 57344K-&amp;gt;49152K(251392K), [Metaspace: 20480K-&amp;gt;20480K(1067008K)], 0.1056299 secs] [Times: user=0.11 sys=0.01, real=0.11 secs]
2024-03-23T10:15:30.123-0800:
8.123: [GC (Allocation Failure) [PSYoungGen: 65536K-&amp;gt;16384K(76288K)] 114688K-&amp;gt;81920K(251392K), 0.0257884 secs] [Times: user=0.03 sys=0.01, real=0.03 secs]
2024-03-23T10:15:32.456-0800:
10.456: [GC (Allocation Failure) [PSYoungGen: 81920K-&amp;gt;20480K(76288K)] 139264K-&amp;gt;106496K(251392K), 0.0212413 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
2024-03-23T10:15:34.789-0800:
12.789: [Full GC (Ergonomics) [PSYoungGen: 20480K-&amp;gt;0K(76288K)] [ParOldGen: 86016K-&amp;gt;90112K(200704K)] 106496K-&amp;gt;90112K(251392K), [Metaspace: 20480K-&amp;gt;20480K(1067008K)], 0.1468552 secs] [Times: user=0.14 sys=0.01, real=0.15 secs]&lt;/p>
&lt;/blockquote></description></item></channel></rss>